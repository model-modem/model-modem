{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Model Modem \u2693\ufe0e Rationale \u2693\ufe0e The concept of a blog has always appealed to me. I often find great tutorials and interesting content in other author's blogs. But, I frankly do not have the time or energy needed to maintain a blog that would be worth reading. I gave this issue a lot of thought and ultimately decided that what would be simpler would be a site where I could jot down my notes and findings on various topics in a less idempotent way. Blogs suffer from the traditional expectation that each article, once written, will not change over time. This puts a ton of pressure on blog authors to fully explore and expound upon their ideas on the first draft. What this site is attempting to achieve is a to present an evolving compendium generally composed of technical findings and documentation. Each page is subject to change and may move around as time goes on. Photo by Patrick Tomasso on Unsplash","title":"About"},{"location":"#model-modem","text":"","title":"Model Modem"},{"location":"#rationale","text":"The concept of a blog has always appealed to me. I often find great tutorials and interesting content in other author's blogs. But, I frankly do not have the time or energy needed to maintain a blog that would be worth reading. I gave this issue a lot of thought and ultimately decided that what would be simpler would be a site where I could jot down my notes and findings on various topics in a less idempotent way. Blogs suffer from the traditional expectation that each article, once written, will not change over time. This puts a ton of pressure on blog authors to fully explore and expound upon their ideas on the first draft. What this site is attempting to achieve is a to present an evolving compendium generally composed of technical findings and documentation. Each page is subject to change and may move around as time goes on. Photo by Patrick Tomasso on Unsplash","title":"Rationale"},{"location":"dev/cheat-codes/","text":"Cheat Codes \u2693\ufe0e The Konami Code Docker \u2693\ufe0e Below are some less-common Docker commands. Get Runtime Statistics \u2693\ufe0e 1 docker stats $( docker ps --format = '{{.Names}}' ) This command will display detailed information about the docker containers you have running locally including: Container Name Name CPU % Memory Usage/Limit Memory % Network I/O Block Storage I/O Process IDs Remove All Stopped Containers \u2693\ufe0e 1 docker rm $( docker ps -a -q ) If you have a lot of stopped containers (perhaps you didn't supply a container name when running images), you can run this command to automatically remove all stopped containers. Remove Untagged Containers \u2693\ufe0e 1 docker images -q --filter \"dangling=true\" | xargs docker rmi Prune Everything \u2693\ufe0e 1 docker system prune --volumes This command will remove all unused: Containers Images (dangling & unused) Networks (Optionally) Volumes Note If you do not want to prune volumes, remove --volumes from the command above. Troubleshooting \u2693\ufe0e Cannot Connect to Container from Host \u2693\ufe0e In order to connect to a webserver you have running on your docker container, make sure you bind the server to 0.0.0.0 and not 127.0.0.1 like you would locally. Git \u2693\ufe0e Remove Items from Git w/o Deleting \u2693\ufe0e If you ever accidentally added something to your git repository and want to remove it from git without actually deleting the local version, you can run one of these commands: 1 git rm --cached <file-name> Remove a file from git without deleting it locally 1 git rm --cached -r <directory-name> Remove an entire directory from git without deleting it locally Repoint Remote Endpoint \u2693\ufe0e 1 git remote set-url <remote-name> <url> If you ever move your code to a new remote system (say from GitHub to GitLab), you can use this command to re-point your remote without having to remove and add the remote from scratch. Python \u2693\ufe0e Lock pip Dependencies \u2693\ufe0e 1 pip freeze > requirements.txt Run as a Module \u2693\ufe0e 1 pip install -e .","title":"Cheat Codes"},{"location":"dev/cheat-codes/#cheat-codes","text":"The Konami Code","title":"Cheat Codes"},{"location":"dev/cheat-codes/#docker","text":"Below are some less-common Docker commands.","title":"Docker"},{"location":"dev/cheat-codes/#get-runtime-statistics","text":"1 docker stats $( docker ps --format = '{{.Names}}' ) This command will display detailed information about the docker containers you have running locally including: Container Name Name CPU % Memory Usage/Limit Memory % Network I/O Block Storage I/O Process IDs","title":"Get Runtime Statistics"},{"location":"dev/cheat-codes/#remove-all-stopped-containers","text":"1 docker rm $( docker ps -a -q ) If you have a lot of stopped containers (perhaps you didn't supply a container name when running images), you can run this command to automatically remove all stopped containers.","title":"Remove All Stopped Containers"},{"location":"dev/cheat-codes/#remove-untagged-containers","text":"1 docker images -q --filter \"dangling=true\" | xargs docker rmi","title":"Remove Untagged Containers"},{"location":"dev/cheat-codes/#prune-everything","text":"1 docker system prune --volumes This command will remove all unused: Containers Images (dangling & unused) Networks (Optionally) Volumes Note If you do not want to prune volumes, remove --volumes from the command above.","title":"Prune Everything"},{"location":"dev/cheat-codes/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"dev/cheat-codes/#cannot-connect-to-container-from-host","text":"In order to connect to a webserver you have running on your docker container, make sure you bind the server to 0.0.0.0 and not 127.0.0.1 like you would locally.","title":"Cannot Connect to Container from Host"},{"location":"dev/cheat-codes/#git","text":"","title":"Git"},{"location":"dev/cheat-codes/#remove-items-from-git-wo-deleting","text":"If you ever accidentally added something to your git repository and want to remove it from git without actually deleting the local version, you can run one of these commands: 1 git rm --cached <file-name> Remove a file from git without deleting it locally 1 git rm --cached -r <directory-name> Remove an entire directory from git without deleting it locally","title":"Remove Items from Git w/o Deleting"},{"location":"dev/cheat-codes/#repoint-remote-endpoint","text":"1 git remote set-url <remote-name> <url> If you ever move your code to a new remote system (say from GitHub to GitLab), you can use this command to re-point your remote without having to remove and add the remote from scratch.","title":"Repoint Remote Endpoint"},{"location":"dev/cheat-codes/#python","text":"","title":"Python"},{"location":"dev/cheat-codes/#lock-pip-dependencies","text":"1 pip freeze > requirements.txt","title":"Lock pip Dependencies"},{"location":"dev/cheat-codes/#run-as-a-module","text":"1 pip install -e .","title":"Run as a Module"},{"location":"dev/mkdocs/","text":"MKDocs \u2693\ufe0e Troubleshooting \u2693\ufe0e GitHub Pages Custom Domain \u2693\ufe0e If you are deploying your MKDocs site via the mkdocs gh-deploy command and finding that it is resetting your custom domain name settings, there is a solution for that. There is an undocumented feature of MKDocs that it will publish your site to GitHub Pages using a custom domain name only if you create a file called CNAME which contains the custom domain name of your site. If you do not create this special file, your site's custom domain name will be wiped out each time you deploy your site. For example if your site was called modelmodem.com you would (and I did) create a file called CNAME and place it at the root of your docs_dir . 1 modelmodem.com File /docs/CNAME","title":"MKDocs"},{"location":"dev/mkdocs/#mkdocs","text":"","title":"MKDocs"},{"location":"dev/mkdocs/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"dev/mkdocs/#github-pages-custom-domain","text":"If you are deploying your MKDocs site via the mkdocs gh-deploy command and finding that it is resetting your custom domain name settings, there is a solution for that. There is an undocumented feature of MKDocs that it will publish your site to GitHub Pages using a custom domain name only if you create a file called CNAME which contains the custom domain name of your site. If you do not create this special file, your site's custom domain name will be wiped out each time you deploy your site. For example if your site was called modelmodem.com you would (and I did) create a file called CNAME and place it at the root of your docs_dir . 1 modelmodem.com File /docs/CNAME","title":"GitHub Pages Custom Domain"},{"location":"dev/docker/config/","text":"Docker Configuration \u2693\ufe0e Logging \u2693\ufe0e It is standard best practice to send logs of applications running in a Docker container to the standard output and error streams of the image's OS ( stdout and stderr ). Once you do that, you can view those logs by running the docker logs command. When applications running in your image are designed to write their logs to a file\u2014rather than to the standard output streams\u2014you can use the file handles below (provided by Docker) to stream log events to stdout or stderr . Type File Location STDOUT /proc/self/fd/1 STDERR /proc/self/fd/2","title":"Configuration"},{"location":"dev/docker/config/#docker-configuration","text":"","title":"Docker Configuration"},{"location":"dev/docker/config/#logging","text":"It is standard best practice to send logs of applications running in a Docker container to the standard output and error streams of the image's OS ( stdout and stderr ). Once you do that, you can view those logs by running the docker logs command. When applications running in your image are designed to write their logs to a file\u2014rather than to the standard output streams\u2014you can use the file handles below (provided by Docker) to stream log events to stdout or stderr . Type File Location STDOUT /proc/self/fd/1 STDERR /proc/self/fd/2","title":"Logging"},{"location":"dev/docker/compose/build/","text":"The Compose Specification - Build support \u2693\ufe0e Note This document has been reproduced here from its original source to provide a better reading experience. Note: Build is an OPTIONAL part of the Compose Specification Introduction \u2693\ufe0e Compose specification is a platform-neutral way to define multi-container applications. A Compose implementation focussing on development use-case to run application on local machine will obviously also support (re)building application from sources. The Compose Build specification allows to define the build process within a Compose file in a portable way. Definitions \u2693\ufe0e Compose Specification is extended to support an OPTIONAL build subsection on services. This section define the build requirements for service container image. Only a subset of Compose file services MAY define such a Build subsection, others being created based on Image attribute. When a Build subsection is present for a service, it is valid for a Compose file to miss an Image attribute for corresponding service, as Compose implementation can build image from source. Build can be either specified as a single string defining a context path, or as a detailled build definition. In the former case, the whole path is used as a Docker context to execute a docker build, looking for a canonical Dockerfile at context root. Context path can be absolute or relative, and if so relative path MUST be resolved from Compose file parent folder. As an absolute path prevent the Compose file to be portable, Compose implementation SHOULD warn user accordingly. In the later case, build arguments can be specified, including an alternate Dockerfile location. This one can be absolute or relative path. If Dockerfile path is relative, it MUST be resolved from context path. As an absolute path prevent the Compose file to be portable, Compose implementation SHOULD warn user if an absolute alternate Dockerfile path is used. Consistency with Image \u2693\ufe0e When service definition do include both Image attribute and a Build section, Compose implementation can't guarantee a pulled image is strictly equivalent to building the same image from sources. Without any explicit user directives, Compose implementation with Build support MUST first try to pull Image, then build from source if image was not found on registry. Compose implementation MAY offer options to customize this behaviour by user request. Publishing built images \u2693\ufe0e Compose implementation with Build support SHOULD offer an option to push built images to a registry. Doing so, it MUST NOT try to push service images without an Image attribute. Compose implementation SHOULD warn user about missing Image attribute which prevent image being pushed. Compose implementation MAY offer a mechanism to compute an Image attribute for service when not explicitly declared in yaml file. In such a case, the resulting Compose configuration is considered to have a valid Image attribute, whenever the actual raw yaml file doesn't explicitly declare one. Illustrative sample \u2693\ufe0e The following sample illustrates Compose specification concepts with a concrete sample application. The sample is non-normative. 1 2 3 4 5 6 7 8 9 10 11 12 13 services : frontend : image : awesome/webapp build : ./webapp backend : image : awesome/database build : context : backend dockerfile : ../backend.Dockerfile custom : build : ~/custom When used to build service images from source, such a Compose file will create three docker images: awesome/webapp docker image is build using webapp sub-directory within Compose file parent folder as docker build context. Lack of a Dockerfile within this folder will throw an error. awesome/database docker image is build using backend sub-directory within Compose file parent folder. backend.Dockerfile file is used to define build steps, this file is searched relative to context path, which means for this sample .. will resolve to Compose file parent folder, so backend.Dockerfile is a sibling file. a docker image is build using custom directory within user's HOME as docker context. Compose implementation warn user about non-portable path used to build image. On push, both awesome/webapp and awesome/database docker images are pushed to (default) registry. custom service image is skipped as no Image attribute is set and user is warned about this missing attribute. Build definition \u2693\ufe0e The build element define configuration options that are applied by Compose implementations to build Docker image from source. build can be specified either as a string containing a path to the build context or a detailled structure: 1 2 3 services: webapp: build: ./dir Using this string syntax, only the build context can be configured as a relative path to the Compose file's parent folder. This path MUST be a directory and contain a Dockerfile . Alternatively build can be an object with fields defined as follow context (REQUIRED) \u2693\ufe0e context defines either a path to a directory containing a Dockerfile, or a url to a git repository. When the value supplied is a relative path, it MUST be interpreted as relative to the location of the Compose file. Compose implementations MUST warn user about absolute path used to define build context as those prevent Compose file for being portable. 1 2 build: context: ./dir dockerfile \u2693\ufe0e dockerfile allows to set an alternate Dockerfile. A relative path MUST be resolved from the build context. Compose implementations MUST warn user about absolute path used to define Dockerfile as those prevent Compose file for being portable. 1 2 3 build: context: . dockerfile: webapp.Dockerfile args \u2693\ufe0e args define build arguments, i.e. Dockerfile ARG values. Using following Dockerfile: 1 2 ARG GIT_COMMIT RUN echo \"Based on commit: $GIT_COMMIT \" args can be set in Compose file under the build key to define GIT_COMMIT . args can be set a mapping or a list: 1 2 3 4 build: context: . args: GIT_COMMIT: cdc3b19 1 2 3 4 build: context: . args: - GIT_COMMIT=cdc3b19 Value can be omited when specifying a build argument, in which case its value at build time MUST be obtained by user interaction, otherwise build arg won't be set when building the Docker image. 1 2 args: - GIT_COMMIT cache_from \u2693\ufe0e cache_from defines a list of images that the Image builder SHOULD uses for cache resolution. 1 2 3 4 5 build: context: . cache_from: - alpine:latest - corp/web_app:3.14 extra_hosts \u2693\ufe0e extra_hosts adds hostname mappings at build-time. Use the same syntax as extra_hosts . 1 2 3 extra_hosts: - \"somehost:162.242.195.82\" - \"otherhost:50.31.209.229\" Compose implementations MUST create matching entry with the IP address and hostname in the container's network configuration, which means for Linux /etc/hosts will get extra lines: 1 2 162.242.195.82 somehost 50.31.209.229 otherhost isolation \u2693\ufe0e isolation specifies a build\u2019s container isolation technology. Like isolation supported values are platform-specific. labels \u2693\ufe0e labels add metadata to the resulting image. labrls can be set either as an array or a map. reverse-DNS notation SHOULD be used to prevent labels from conflicting with those used by other software. 1 2 3 4 5 6 build: context: . labels: com.example.description: \"Accounting webapp\" com.example.department: \"Finance\" com.example.label-with-empty-value: \"\" 1 2 3 4 5 6 build: context: . labels: - \"com.example.description=Accounting webapp\" - \"com.example.department=Finance\" - \"com.example.label-with-empty-value\" shm_size \u2693\ufe0e shm_size set the size of the shared memory ( /dev/shm partition on Linux) allocated for building Docker image. Specify as an integer value representing the number of bytes or as a string expressing a byte value . 1 2 3 build: context: . shm_size: '2gb' 1 2 3 build : context : . shm_size : 10000000 target \u2693\ufe0e target defines the stage to build as defined inside a multi-stage Dockerfile . 1 2 3 build: context: . target: prod Implementations \u2693\ufe0e docker-compose buildX bake","title":"Build"},{"location":"dev/docker/compose/build/#the-compose-specification-build-support","text":"Note This document has been reproduced here from its original source to provide a better reading experience. Note: Build is an OPTIONAL part of the Compose Specification","title":"The Compose Specification - Build support"},{"location":"dev/docker/compose/build/#introduction","text":"Compose specification is a platform-neutral way to define multi-container applications. A Compose implementation focussing on development use-case to run application on local machine will obviously also support (re)building application from sources. The Compose Build specification allows to define the build process within a Compose file in a portable way.","title":"Introduction"},{"location":"dev/docker/compose/build/#definitions","text":"Compose Specification is extended to support an OPTIONAL build subsection on services. This section define the build requirements for service container image. Only a subset of Compose file services MAY define such a Build subsection, others being created based on Image attribute. When a Build subsection is present for a service, it is valid for a Compose file to miss an Image attribute for corresponding service, as Compose implementation can build image from source. Build can be either specified as a single string defining a context path, or as a detailled build definition. In the former case, the whole path is used as a Docker context to execute a docker build, looking for a canonical Dockerfile at context root. Context path can be absolute or relative, and if so relative path MUST be resolved from Compose file parent folder. As an absolute path prevent the Compose file to be portable, Compose implementation SHOULD warn user accordingly. In the later case, build arguments can be specified, including an alternate Dockerfile location. This one can be absolute or relative path. If Dockerfile path is relative, it MUST be resolved from context path. As an absolute path prevent the Compose file to be portable, Compose implementation SHOULD warn user if an absolute alternate Dockerfile path is used.","title":"Definitions"},{"location":"dev/docker/compose/build/#consistency-with-image","text":"When service definition do include both Image attribute and a Build section, Compose implementation can't guarantee a pulled image is strictly equivalent to building the same image from sources. Without any explicit user directives, Compose implementation with Build support MUST first try to pull Image, then build from source if image was not found on registry. Compose implementation MAY offer options to customize this behaviour by user request.","title":"Consistency with Image"},{"location":"dev/docker/compose/build/#publishing-built-images","text":"Compose implementation with Build support SHOULD offer an option to push built images to a registry. Doing so, it MUST NOT try to push service images without an Image attribute. Compose implementation SHOULD warn user about missing Image attribute which prevent image being pushed. Compose implementation MAY offer a mechanism to compute an Image attribute for service when not explicitly declared in yaml file. In such a case, the resulting Compose configuration is considered to have a valid Image attribute, whenever the actual raw yaml file doesn't explicitly declare one.","title":"Publishing built images"},{"location":"dev/docker/compose/build/#illustrative-sample","text":"The following sample illustrates Compose specification concepts with a concrete sample application. The sample is non-normative. 1 2 3 4 5 6 7 8 9 10 11 12 13 services : frontend : image : awesome/webapp build : ./webapp backend : image : awesome/database build : context : backend dockerfile : ../backend.Dockerfile custom : build : ~/custom When used to build service images from source, such a Compose file will create three docker images: awesome/webapp docker image is build using webapp sub-directory within Compose file parent folder as docker build context. Lack of a Dockerfile within this folder will throw an error. awesome/database docker image is build using backend sub-directory within Compose file parent folder. backend.Dockerfile file is used to define build steps, this file is searched relative to context path, which means for this sample .. will resolve to Compose file parent folder, so backend.Dockerfile is a sibling file. a docker image is build using custom directory within user's HOME as docker context. Compose implementation warn user about non-portable path used to build image. On push, both awesome/webapp and awesome/database docker images are pushed to (default) registry. custom service image is skipped as no Image attribute is set and user is warned about this missing attribute.","title":"Illustrative sample"},{"location":"dev/docker/compose/build/#build-definition","text":"The build element define configuration options that are applied by Compose implementations to build Docker image from source. build can be specified either as a string containing a path to the build context or a detailled structure: 1 2 3 services: webapp: build: ./dir Using this string syntax, only the build context can be configured as a relative path to the Compose file's parent folder. This path MUST be a directory and contain a Dockerfile . Alternatively build can be an object with fields defined as follow","title":"Build definition"},{"location":"dev/docker/compose/build/#context-required","text":"context defines either a path to a directory containing a Dockerfile, or a url to a git repository. When the value supplied is a relative path, it MUST be interpreted as relative to the location of the Compose file. Compose implementations MUST warn user about absolute path used to define build context as those prevent Compose file for being portable. 1 2 build: context: ./dir","title":"context (REQUIRED)"},{"location":"dev/docker/compose/build/#dockerfile","text":"dockerfile allows to set an alternate Dockerfile. A relative path MUST be resolved from the build context. Compose implementations MUST warn user about absolute path used to define Dockerfile as those prevent Compose file for being portable. 1 2 3 build: context: . dockerfile: webapp.Dockerfile","title":"dockerfile"},{"location":"dev/docker/compose/build/#args","text":"args define build arguments, i.e. Dockerfile ARG values. Using following Dockerfile: 1 2 ARG GIT_COMMIT RUN echo \"Based on commit: $GIT_COMMIT \" args can be set in Compose file under the build key to define GIT_COMMIT . args can be set a mapping or a list: 1 2 3 4 build: context: . args: GIT_COMMIT: cdc3b19 1 2 3 4 build: context: . args: - GIT_COMMIT=cdc3b19 Value can be omited when specifying a build argument, in which case its value at build time MUST be obtained by user interaction, otherwise build arg won't be set when building the Docker image. 1 2 args: - GIT_COMMIT","title":"args"},{"location":"dev/docker/compose/build/#cache_from","text":"cache_from defines a list of images that the Image builder SHOULD uses for cache resolution. 1 2 3 4 5 build: context: . cache_from: - alpine:latest - corp/web_app:3.14","title":"cache_from"},{"location":"dev/docker/compose/build/#extra_hosts","text":"extra_hosts adds hostname mappings at build-time. Use the same syntax as extra_hosts . 1 2 3 extra_hosts: - \"somehost:162.242.195.82\" - \"otherhost:50.31.209.229\" Compose implementations MUST create matching entry with the IP address and hostname in the container's network configuration, which means for Linux /etc/hosts will get extra lines: 1 2 162.242.195.82 somehost 50.31.209.229 otherhost","title":"extra_hosts"},{"location":"dev/docker/compose/build/#isolation","text":"isolation specifies a build\u2019s container isolation technology. Like isolation supported values are platform-specific.","title":"isolation"},{"location":"dev/docker/compose/build/#labels","text":"labels add metadata to the resulting image. labrls can be set either as an array or a map. reverse-DNS notation SHOULD be used to prevent labels from conflicting with those used by other software. 1 2 3 4 5 6 build: context: . labels: com.example.description: \"Accounting webapp\" com.example.department: \"Finance\" com.example.label-with-empty-value: \"\" 1 2 3 4 5 6 build: context: . labels: - \"com.example.description=Accounting webapp\" - \"com.example.department=Finance\" - \"com.example.label-with-empty-value\"","title":"labels"},{"location":"dev/docker/compose/build/#shm_size","text":"shm_size set the size of the shared memory ( /dev/shm partition on Linux) allocated for building Docker image. Specify as an integer value representing the number of bytes or as a string expressing a byte value . 1 2 3 build: context: . shm_size: '2gb' 1 2 3 build : context : . shm_size : 10000000","title":"shm_size"},{"location":"dev/docker/compose/build/#target","text":"target defines the stage to build as defined inside a multi-stage Dockerfile . 1 2 3 build: context: . target: prod","title":"target"},{"location":"dev/docker/compose/build/#implementations","text":"docker-compose buildX bake","title":"Implementations"},{"location":"dev/docker/compose/deploy/","text":"The Compose Specification - Deployment support \u2693\ufe0e Note This document has been reproduced here from its original source to provide a better reading experience. Note: Deployment is an OPTIONAL part of the Compose Specification Introduction \u2693\ufe0e Compose specification is a platform-neutral way to define multi-container applications. A Compose implementation supporting deployment of application model MAY require some additional metadata as the Compose application model is way too abstract to reflect actual infrastructure needs per service, or lifecycle constraints. Compose Specification Deployment allows users to declare additional metadata on services so Compose implementations get relevant data to allocate adequate resources on platform and configure them to match user's needs. Definitions \u2693\ufe0e Compose Specification is extended to support an OPTIONAL deploy subsection on services. This section define runtime requirements for a service. endpoint_mode \u2693\ufe0e endpoint_mode specifies a service discovery method for external clients connecting to a service. Default and available values are platform specific, anyway the Compose specification define two canonical values: endpoint_mode: vip : Assigns the service a virtual IP (VIP) that acts as the front end for clients to reach the service on a network. Platform routes requests between the client and nodes running the service, without client knowledge of how many nodes are participating in the service or their IP addresses or ports. endpoint_mode: dnsrr : Platform sets up DNS entries for the service such that a DNS query for the service name returns a list of IP addresses (DNS round-robin), and the client connects directly to one of these. 1 2 3 4 5 6 7 8 9 services: frontend: image: awesome/webapp ports: - \"8080:80\" deploy: mode: replicated replicas: 2 endpoint_mode: vip labels \u2693\ufe0e labels specifies metadata for the service. These labels MUST only be set on the service and not on any containers for the service. This assumes the platform as some native concept of \"service\" that can match Compose application model. 1 2 3 4 5 6 services: frontend: image: awesome/webapp deploy: labels: com.example.description: \"This label will appear on the web service\" mode \u2693\ufe0e mode define the replication model used to run the service on platform. Either global (exactly one container per physical node) or replicated (a specified number of containers). The default is replicated . 1 2 3 4 5 services: frontend: image: awesome/webapp deploy: mode: global placement \u2693\ufe0e placement specifies constraints and preferences for platform to select a physical node to run service containers. constraints \u2693\ufe0e constraints defines a REQUIRED property the platform's node MUST fulfill to run service container. Can be set either by a list or a map with string values. 1 2 3 4 deploy: placement: constraints: - disktype=ssd 1 2 3 4 deploy: placement: constraints: disktype: ssd preferences \u2693\ufe0e preferences defines a property the platform's node SHOULD fulfill to run service container. Can be set either by a list or a map with string values. 1 2 3 4 deploy: placement: preferences: - datacenter=us-east 1 2 3 4 deploy: placement: preferences: datacenter: us-east replicas \u2693\ufe0e If the service is replicated (which is the default), replicas specifies the number of containers that SHOULD be running at any given time. 1 2 3 4 5 6 services: fronted: image: awesome/webapp deploy: mode: replicated replicas: 6 resources \u2693\ufe0e resources configures physical resource constraints for container to run on platform. Those constraints can be configured as a: - limits : The platform MUST prevent container to allocate more - reservations : The platform MUST guarantee container can allocate at least the configured amount 1 2 3 4 5 6 7 8 9 10 11 services: frontend: image: awesome/webapp deploy: resources: limits: cpus: '0.50' memory: 50M reservations: cpus: '0.25' memory: 20M cpus \u2693\ufe0e cpus configures a limit or reservation for how much of the available CPU resources (as number of cores) a container can use. memory \u2693\ufe0e memory configures a limit or reservation on the amount of memory a container can allocate, set as a string expressing a byte value . devices \u2693\ufe0e devices configures reservations of the devices a container can use. It contains a list of reservations, each set as an object with the following parameters: capabilities , driver , count , device_ids and options . Devices are reserved using a list of capabilities, making capabilities the only required field. A device MUST satisfy all the requested capabilities for a successful reservation. capabilities \u2693\ufe0e capabilities are set as a list of strings, expressing both generic and driver specific capabilities. The following generic capabilities are recognized today: gpu : Graphics accelerator tpu : AI accelerator To avoid name clashes, driver specific capabilities MUST be prefixed with the driver name. For example, reserving an nVidia CUDA-enabled accelerator might look like this: 1 2 3 4 5 deploy: resources: reservations: devices: - capabilities: [\"nvidia-compute\"] driver \u2693\ufe0e A different driver for the reserved device(s) can be requested using driver field. The value is specified as a string. 1 2 3 4 5 6 deploy: resources: reservations: devices: - capabilities: [\"nvidia-compute\"] driver: nvidia count \u2693\ufe0e If count is set to all or not specified, Compose implementations MUST reserve all devices that satisfy the requested capabilities. Otherwise, Compose implementations MUST reserve at least the number of devices specified. The value is specified as an integer. 1 2 3 4 5 6 deploy: resources: reservations: devices: - capabilities: [\"tpu\"] count: 2 count and device_ids fields are exclusive. Compose implementations MUST return an error if both are specified. device_ids \u2693\ufe0e If device_ids is set, Compose implementations MUST reserve devices with the specified IDs providing they satisfy the requested capabilities. The value is specified as a list of strings. 1 2 3 4 5 6 deploy: resources: reservations: devices: - capabilities: [\"gpu\"] device_ids: [\"GPU-f123d1c9-26bb-df9b-1c23-4a731f61d8c7\"] count and device_ids fields are exclusive. Compose implementations MUST return an error if both are specified. options \u2693\ufe0e Driver specific options can be set with options as key-value pairs. 1 2 3 4 5 6 7 8 deploy: resources: reservations: devices: - capabilities: [\"gpu\"] driver: gpuvendor options: virtualization: false restart_policy \u2693\ufe0e restart_policy configures if and how to restart containers when they exit. If restart_policy is not set, Compose implementations MUST consider restart field set by service configuration. condition : One of none , on-failure or any (default: any ). delay : How long to wait between restart attempts, specified as a duration (default: 0). max_attempts : How many times to attempt to restart a container before giving up (default: never give up). If the restart does not succeed within the configured window , this attempt doesn't count toward the configured max_attempts value. For example, if max_attempts is set to '2', and the restart fails on the first attempt, more than two restarts MUST be attempted. window : How long to wait before deciding if a restart has succeeded, specified as a duration (default: decide immediately). 1 2 3 4 5 6 deploy: restart_policy: condition: on-failure delay: 5s max_attempts: 3 window: 120s rollback_config \u2693\ufe0e rollback_config configures how the service should be rollbacked in case of a failing update. parallelism : The number of containers to rollback at a time. If set to 0, all containers rollback simultaneously. delay : The time to wait between each container group's rollback (default 0s). failure_action : What to do if a rollback fails. One of continue or pause (default pause ) monitor : Duration after each task update to monitor for failure (ns|us|ms|s|m|h) (default 0s). max_failure_ratio : Failure rate to tolerate during a rollback (default 0). order : Order of operations during rollbacks. One of stop-first (old task is stopped before starting new one), or start-first (new task is started first, and the running tasks briefly overlap) (default stop-first ). update_config \u2693\ufe0e update_config configures how the service should be updated. Useful for configuring rolling updates. parallelism : The number of containers to update at a time. delay : The time to wait between updating a group of containers. failure_action : What to do if an update fails. One of continue , rollback , or pause (default: pause ). monitor : Duration after each task update to monitor for failure (ns|us|ms|s|m|h) (default 0s). max_failure_ratio : Failure rate to tolerate during an update. order : Order of operations during updates. One of stop-first (old task is stopped before starting new one), or start-first (new task is started first, and the running tasks briefly overlap) (default stop-first ). 1 2 3 4 5 deploy: update_config: parallelism: 2 delay: 10s order: stop-first","title":"Deploy"},{"location":"dev/docker/compose/deploy/#the-compose-specification-deployment-support","text":"Note This document has been reproduced here from its original source to provide a better reading experience. Note: Deployment is an OPTIONAL part of the Compose Specification","title":"The Compose Specification - Deployment support"},{"location":"dev/docker/compose/deploy/#introduction","text":"Compose specification is a platform-neutral way to define multi-container applications. A Compose implementation supporting deployment of application model MAY require some additional metadata as the Compose application model is way too abstract to reflect actual infrastructure needs per service, or lifecycle constraints. Compose Specification Deployment allows users to declare additional metadata on services so Compose implementations get relevant data to allocate adequate resources on platform and configure them to match user's needs.","title":"Introduction"},{"location":"dev/docker/compose/deploy/#definitions","text":"Compose Specification is extended to support an OPTIONAL deploy subsection on services. This section define runtime requirements for a service.","title":"Definitions"},{"location":"dev/docker/compose/deploy/#endpoint_mode","text":"endpoint_mode specifies a service discovery method for external clients connecting to a service. Default and available values are platform specific, anyway the Compose specification define two canonical values: endpoint_mode: vip : Assigns the service a virtual IP (VIP) that acts as the front end for clients to reach the service on a network. Platform routes requests between the client and nodes running the service, without client knowledge of how many nodes are participating in the service or their IP addresses or ports. endpoint_mode: dnsrr : Platform sets up DNS entries for the service such that a DNS query for the service name returns a list of IP addresses (DNS round-robin), and the client connects directly to one of these. 1 2 3 4 5 6 7 8 9 services: frontend: image: awesome/webapp ports: - \"8080:80\" deploy: mode: replicated replicas: 2 endpoint_mode: vip","title":"endpoint_mode"},{"location":"dev/docker/compose/deploy/#labels","text":"labels specifies metadata for the service. These labels MUST only be set on the service and not on any containers for the service. This assumes the platform as some native concept of \"service\" that can match Compose application model. 1 2 3 4 5 6 services: frontend: image: awesome/webapp deploy: labels: com.example.description: \"This label will appear on the web service\"","title":"labels"},{"location":"dev/docker/compose/deploy/#mode","text":"mode define the replication model used to run the service on platform. Either global (exactly one container per physical node) or replicated (a specified number of containers). The default is replicated . 1 2 3 4 5 services: frontend: image: awesome/webapp deploy: mode: global","title":"mode"},{"location":"dev/docker/compose/deploy/#placement","text":"placement specifies constraints and preferences for platform to select a physical node to run service containers.","title":"placement"},{"location":"dev/docker/compose/deploy/#constraints","text":"constraints defines a REQUIRED property the platform's node MUST fulfill to run service container. Can be set either by a list or a map with string values. 1 2 3 4 deploy: placement: constraints: - disktype=ssd 1 2 3 4 deploy: placement: constraints: disktype: ssd","title":"constraints"},{"location":"dev/docker/compose/deploy/#preferences","text":"preferences defines a property the platform's node SHOULD fulfill to run service container. Can be set either by a list or a map with string values. 1 2 3 4 deploy: placement: preferences: - datacenter=us-east 1 2 3 4 deploy: placement: preferences: datacenter: us-east","title":"preferences"},{"location":"dev/docker/compose/deploy/#replicas","text":"If the service is replicated (which is the default), replicas specifies the number of containers that SHOULD be running at any given time. 1 2 3 4 5 6 services: fronted: image: awesome/webapp deploy: mode: replicated replicas: 6","title":"replicas"},{"location":"dev/docker/compose/deploy/#resources","text":"resources configures physical resource constraints for container to run on platform. Those constraints can be configured as a: - limits : The platform MUST prevent container to allocate more - reservations : The platform MUST guarantee container can allocate at least the configured amount 1 2 3 4 5 6 7 8 9 10 11 services: frontend: image: awesome/webapp deploy: resources: limits: cpus: '0.50' memory: 50M reservations: cpus: '0.25' memory: 20M","title":"resources"},{"location":"dev/docker/compose/deploy/#cpus","text":"cpus configures a limit or reservation for how much of the available CPU resources (as number of cores) a container can use.","title":"cpus"},{"location":"dev/docker/compose/deploy/#memory","text":"memory configures a limit or reservation on the amount of memory a container can allocate, set as a string expressing a byte value .","title":"memory"},{"location":"dev/docker/compose/deploy/#devices","text":"devices configures reservations of the devices a container can use. It contains a list of reservations, each set as an object with the following parameters: capabilities , driver , count , device_ids and options . Devices are reserved using a list of capabilities, making capabilities the only required field. A device MUST satisfy all the requested capabilities for a successful reservation.","title":"devices"},{"location":"dev/docker/compose/deploy/#capabilities","text":"capabilities are set as a list of strings, expressing both generic and driver specific capabilities. The following generic capabilities are recognized today: gpu : Graphics accelerator tpu : AI accelerator To avoid name clashes, driver specific capabilities MUST be prefixed with the driver name. For example, reserving an nVidia CUDA-enabled accelerator might look like this: 1 2 3 4 5 deploy: resources: reservations: devices: - capabilities: [\"nvidia-compute\"]","title":"capabilities"},{"location":"dev/docker/compose/deploy/#driver","text":"A different driver for the reserved device(s) can be requested using driver field. The value is specified as a string. 1 2 3 4 5 6 deploy: resources: reservations: devices: - capabilities: [\"nvidia-compute\"] driver: nvidia","title":"driver"},{"location":"dev/docker/compose/deploy/#count","text":"If count is set to all or not specified, Compose implementations MUST reserve all devices that satisfy the requested capabilities. Otherwise, Compose implementations MUST reserve at least the number of devices specified. The value is specified as an integer. 1 2 3 4 5 6 deploy: resources: reservations: devices: - capabilities: [\"tpu\"] count: 2 count and device_ids fields are exclusive. Compose implementations MUST return an error if both are specified.","title":"count"},{"location":"dev/docker/compose/deploy/#device_ids","text":"If device_ids is set, Compose implementations MUST reserve devices with the specified IDs providing they satisfy the requested capabilities. The value is specified as a list of strings. 1 2 3 4 5 6 deploy: resources: reservations: devices: - capabilities: [\"gpu\"] device_ids: [\"GPU-f123d1c9-26bb-df9b-1c23-4a731f61d8c7\"] count and device_ids fields are exclusive. Compose implementations MUST return an error if both are specified.","title":"device_ids"},{"location":"dev/docker/compose/deploy/#options","text":"Driver specific options can be set with options as key-value pairs. 1 2 3 4 5 6 7 8 deploy: resources: reservations: devices: - capabilities: [\"gpu\"] driver: gpuvendor options: virtualization: false","title":"options"},{"location":"dev/docker/compose/deploy/#restart_policy","text":"restart_policy configures if and how to restart containers when they exit. If restart_policy is not set, Compose implementations MUST consider restart field set by service configuration. condition : One of none , on-failure or any (default: any ). delay : How long to wait between restart attempts, specified as a duration (default: 0). max_attempts : How many times to attempt to restart a container before giving up (default: never give up). If the restart does not succeed within the configured window , this attempt doesn't count toward the configured max_attempts value. For example, if max_attempts is set to '2', and the restart fails on the first attempt, more than two restarts MUST be attempted. window : How long to wait before deciding if a restart has succeeded, specified as a duration (default: decide immediately). 1 2 3 4 5 6 deploy: restart_policy: condition: on-failure delay: 5s max_attempts: 3 window: 120s","title":"restart_policy"},{"location":"dev/docker/compose/deploy/#rollback_config","text":"rollback_config configures how the service should be rollbacked in case of a failing update. parallelism : The number of containers to rollback at a time. If set to 0, all containers rollback simultaneously. delay : The time to wait between each container group's rollback (default 0s). failure_action : What to do if a rollback fails. One of continue or pause (default pause ) monitor : Duration after each task update to monitor for failure (ns|us|ms|s|m|h) (default 0s). max_failure_ratio : Failure rate to tolerate during a rollback (default 0). order : Order of operations during rollbacks. One of stop-first (old task is stopped before starting new one), or start-first (new task is started first, and the running tasks briefly overlap) (default stop-first ).","title":"rollback_config"},{"location":"dev/docker/compose/deploy/#update_config","text":"update_config configures how the service should be updated. Useful for configuring rolling updates. parallelism : The number of containers to update at a time. delay : The time to wait between updating a group of containers. failure_action : What to do if an update fails. One of continue , rollback , or pause (default: pause ). monitor : Duration after each task update to monitor for failure (ns|us|ms|s|m|h) (default 0s). max_failure_ratio : Failure rate to tolerate during an update. order : Order of operations during updates. One of stop-first (old task is stopped before starting new one), or start-first (new task is started first, and the running tasks briefly overlap) (default stop-first ). 1 2 3 4 5 deploy: update_config: parallelism: 2 delay: 10s order: stop-first","title":"update_config"},{"location":"dev/docker/compose/spec/","text":"The Compose Specification \u2693\ufe0e Note This document has been reproduced here from its original source to provide a better reading experience. Status of this document \u2693\ufe0e This document specifies the Compose file format used to define multi-containers applications. Distribution of this document is unlimited. The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 . Requirements and optional attributes \u2693\ufe0e The Compose specification includes properties designed to target a local OCI container runtime, exposing Linux kernel specific configuration options, but also some Windows container specific properties, as well as cloud platform features related to resource placement on a cluster, replicated application distribution and scalability. We acknowledge that no Compose implementation is expected to support all attributes, and that support for some properties is Platform dependent and can only be confirmed at runtime. The definition of a versioned schema to control the supported properties in a Compose file, established by the docker-compose tool where the Compose file format was designed, doesn't offer any guarantee to the end-user attributes will be actually implemented. The specification defines the expected configuration syntax and behaviour, but - until noted - supporting any of those is OPTIONAL. A Compose implementation to parse a Compose file using unsupported attributes SHOULD warn user. We recommend implementors to support those running modes: default: warn user about unsupported attributes, but ignore them strict: warn user about unsupported attributes and reject the compose file loose: ignore unsupported attributes AND unknown attributes (that were not defined by the spec by the time implementation was created) The Compose application model \u2693\ufe0e The Compose specification allows one to define a platform-agnostic container based application. Such an application is designed as a set of containers which have to both run together with adequate shared resources and communication channels. Computing components of an application are defined as Services . A Service is an abstract concept implemented on platforms by running the same container image (and configuration) one or more times. Services communicate with each other through Networks . In this specification, a Network is a platform capability abstraction to establish an IP route between containers within services connected together. Low-level, platform-specific networking options are grouped into the Network definition and MAY be partially implemented on some platforms. Services store and share persistent data into Volumes . The specification describes such a persistent data as a high-level filesystem mount with global options. Actual platform-specific implementation details are grouped into the Volumes definition and MAY be partially implemented on some platforms. Some services require configuration data that is dependent on the runtime or platform. For this, the specification defines a dedicated concept: Configs . From a Service container point of view, Configs are comparable to Volumes, in that they are files mounted into the container. But the actual definition involves distinct platform resources and services, which are abstracted by this type. A Secret is a specific flavour of configuration data for sensitive data that SHOULD NOT be exposed without security considerations. Secrets are made available to services as files mounted into their containers, but the platform-specific resources to provide sensitive data are specific enough to deserve a distinct concept and definition within the Compose specification. Distinction within Volumes, Configs and Secret allows implementations to offer a comparable abstraction at service level, but cover the specific configuration of adequate platform resources for well identified data usages. A Project is an individual deployment of an application specification on a platform. A project's name is used to group resources together and isolate them from other applications or other installation of the same Compose specified application with distinct parameters. A Compose implementation creating resources on a platform MUST prefix resource names by project and set the label com.docker.compose.project . Illustrative example \u2693\ufe0e The following example illustrates Compose specification concepts with a concrete example application. The example is non-normative. Consider an application split into a frontend web application and a backend service. The frontend is configured at runtime with an HTTP configuration file managed by infrastructure, providing an external domain name, and an HTTPS server certificate injected by the platform's secured secret store. The backend stores data in a persistent volume. Both services communicate with each other on an isolated back-tier network, while frontend is also connected to a front-tier network and exposes port 443 for external usage. 1 2 3 4 5 6 7 8 9 10 11 12 13 (External user) --> 443 [frontend network] | +--------------------+ | frontend service |...ro...<HTTP configuration> | \"webapp\" |...ro...<server certificate> #secured +--------------------+ | [backend network] | +--------------------+ | backend service | r+w ___________________ | \"database\" |=======( persistent volume ) +--------------------+ \\_________________/ The example application is composed of the following parts: - 2 services, backed by Docker images: webapp and database - 1 secret (HTTPS certificate), injected into the frontend - 1 configuration (HTTP), injected into the frontend - 1 persistent volume, attached to the backend - 2 networks 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 services: frontend: image: awesome/webapp ports: - \"443:8043\" networks: - front-tier - back-tier configs: - httpd-config secrets: - server-certificate backend: image: awesome/database volumes: - db-data:/etc/data networks: - back-tier volumes: db-data: driver: flocker driver_opts: size: \"10GiB\" configs: httpd-config: external: true secrets: server-certificate: external: true networks: # The presence of these objects is sufficient to define them front-tier: {} back-tier: {} This example illustrates the distinction between volumes, configs and secrets. While all of them are all exposed to service containers as mounted files or directories, only a volume can be configured for read+write access. Secrets and configs are read-only. The volume configuration allows you to select a volume driver and pass driver options to tweak volume management according to the actual infrastructure. Configs and Secrets rely on platform services, and are declared external as they are not managed as part of the application lifecycle: the Compose implementation will use a platform-specific lookup mechanism to retrieve runtime values. Compose file \u2693\ufe0e The Compose file is a YAML file defining version (DEPRECATED), services (REQUIRED), networks , volumes , configs and secrets . The default path for a Compose file is compose.yaml (preferred) or compose.yml in working directory. Compose implementations SHOULD also support docker-compose.yaml and docker-compose.yml for backward compatibility. If both files exist, Compose implementations MUST prefer canonical compose.yaml one. Multiple Compose files can be combined together to define the application model. The combination of YAML files MUST be implemented by appending/overriding YAML elements based on Compose file order set by the user. Simple attributes and maps get overridden by the highest order Compose file, lists get merged by appending. Relative paths MUST be resolved based on the first Compose file's parent folder, whenever complimentary files being merged are hosted in other folders. As some Compose file elements can both be expressed as single strings or complex objects, merges MUST apply to the expanded form. Profiles \u2693\ufe0e Profiles allow to adjust the Compose application model for various usages and environments. A Compose implementation SHOULD allow the user to define a set of active profiles. The exact mechanism is implementation specific and MAY include command line flags, environment variables, etc. The Services top-level element supports a profiles attribute to define a list of named profiles. Services without a profiles attribute set MUST always be enabled. A service MUST be ignored by the Compose implementation when none of the listed profiles match the active ones, unless the service is explicitly targeted by a command. In that case its profiles MUST be added to the set of active profiles. All other top-level elements are not affected by profiles and are always active. References to other services (by links , extends or shared resource syntax service:xxx ) MUST not automatically enable a component that would otherwise have been ignored by active profiles. Instead the Compose implementation MUST return an error. Illustrative example \u2693\ufe0e 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 services : foo : image : foo bar : image : bar profiles : - test baz : image : baz depends_on : - bar profiles : - test zot : image : zot depends_on : - bar profiles : - debug Compose application model parsed with no profile enabled only contains the foo service. If profile test is enabled, model contains the services bar and baz which are enabled by the test profile and service foo which is always enabled. If profile debug is enabled, model contains both foo and zot services, but not bar and baz and as such the model is invalid regarding the depends_on constraint of zot . If profiles debug and test are enabled, model contains all services: foo , bar , baz and zot . If Compose implementation is executed with bar as explicit service to run, it and the test profile will be active even if test profile is not enabled by the user . If Compose implementation is executed with baz as explicit service to run, the service baz and the profile test will be active and bar will be pulled in by the depends_on constraint. If Compose implementation is executed with zot as explicit service to run, again the model will be invalid regarding the depends_on constraint of zot since zot and bar have no common profiles listed. If Compose implementation is executed with zot as explicit service to run and profile test enabled, profile debug is automatically enabled and service bar is pulled in as a dependency starting both services zot and bar . Version top-level element \u2693\ufe0e Top-level version property is defined by the specification for backward compatibility but is only informative. A Compose implementation SHOULD NOT use this version to select an exact schema to validate the Compose file, but prefer the most recent schema at the time it has been designed. Compose implementations SHOULD validate they can fully parse the Compose file. If some fields are unknown, typically because the Compose file was written with fields defined by a newer version of the specification, Compose implementations SHOULD warn the user. Compose implementations MAY offer options to ignore unknown fields (as defined by \"loose\" mode). Services top-level element \u2693\ufe0e A Service is an abstract definition of a computing resource within an application which can be scaled/replaced independently from other components. Services are backed by a set of containers, run by the platform according to replication requirements and placement constraints. Being backed by containers, Services are defined by a Docker image and set of runtime arguments. All containers within a service are identically created with these arguments. A Compose file MUST declare a services root element as a map whose keys are string representations of service names, and whose values are service definitions. A service definition contains the configuration that is applied to each container started for that service. Each service MAY also include a Build section, which defines how to create the Docker image for the service. Compose implementations MAY support building docker images using this service definition. If not implemented the Build section SHOULD be ignored and the Compose file MUST still be considered valid. Build support is an OPTIONAL aspect of the Compose specification, and is described in detail here Each Service defines runtime constraints and requirements to run its containers. The deploy section groups these constraints and allows the platform to adjust the deployment strategy to best match containers' needs with available resources. Deploy support is an OPTIONAL aspect of the Compose specification, and is described in detail here . If not implemented the Deploy section SHOULD be ignored and the Compose file MUST still be considered valid. deploy \u2693\ufe0e deploy specifies the configuration for the deployment and lifecycle of services, as defined here . blkio_config \u2693\ufe0e blkio_config defines a set of configuration options to set block IO limits for this service. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 services: foo: image: busybox blkio_config: weight: 300 weight_device: - path: /dev/sda weight: 400 device_read_bps: - path: /dev/sdb rate: '12mb' device_read_iops: - path: /dev/sdb rate: 120 device_write_bps: - path: /dev/sdb rate: '1024k' device_write_iops: - path: /dev/sdb rate: 30 device_read_bps, device_write_bps \u2693\ufe0e Set a limit in bytes per second for read / write operations on a given device. Each item in the list MUST have two keys: path : defining the symbolic path to the affected device. rate : either as an integer value representing the number of bytes or as a string expressing a byte value. device_read_iops, device_write_iops \u2693\ufe0e Set a limit in operations per second for read / write operations on a given device. Each item in the list MUST have two keys: path : defining the symbolic path to the affected device. rate : as an integer value representing the permitted number of operations per second. weight \u2693\ufe0e Modify the proportion of bandwidth allocated to this service relative to other services. Takes an integer value between 10 and 1000, with 500 being the default. weight_device \u2693\ufe0e Fine-tune bandwidth allocation by device. Each item in the list must have two keys: path : defining the symbolic path to the affected device. weight : an integer value between 10 and 1000. cpu_count \u2693\ufe0e cpu_count defines the number of usable CPUs for service container. cpu_percent \u2693\ufe0e cpu_percent defines the usable percentage of the available CPUs. cpu_shares \u2693\ufe0e cpu_shares defines (as integer value) service container relative CPU weight versus other containers. cpu_period \u2693\ufe0e cpu_period allow Compose implementations to configure CPU CFS (Completely Fair Scheduler) period when platform is based on Linux kernel. cpu_quota \u2693\ufe0e cpu_quota allow Compose implementations to configure CPU CFS (Completely Fair Scheduler) quota when platform is based on Linux kernel. cpu_rt_runtime \u2693\ufe0e cpu_rt_runtime configures CPU allocation parameters for platform with support for realtime scheduler. Can be either an integer value using microseconds as unit or a duration . 1 2 cpu_rt_runtime: '400ms' cpu_rt_runtime: 95000` cpu_rt_period \u2693\ufe0e cpu_rt_period configures CPU allocation parameters for platform with support for realtime scheduler. Can be either an integer value using microseconds as unit or a duration . 1 2 cpu_rt_period: '1400us' cpu_rt_period: 11000` cpus \u2693\ufe0e DEPRECATED: use deploy.reservations.cpus cpus define the number of (potentially virtual) CPUs to allocate to service containers. This is a fractional number. 0.000 means no limit. cpuset \u2693\ufe0e cpuset defines the explicit CPUs in which to allow execution. Can be a range 0-3 or a list 0,1 build \u2693\ufe0e build specifies the build configuration for creating container image from source, as defined here . cap_add \u2693\ufe0e cap_add specifies additional container capabilities as strings. 1 2 cap_add: - ALL cap_drop \u2693\ufe0e cap_drop specifies container capabilities to drop as strings. 1 2 3 cap_drop: - NET_ADMIN - SYS_ADMIN cgroup_parent \u2693\ufe0e cgroup_parent specifies an OPTIONAL parent cgroup for the container. 1 cgroup_parent: m-executor-abcd command \u2693\ufe0e command overrides the the default command declared by the container image (i.e. by Dockerfile's CMD ). 1 command: bundle exec thin -p 3000 The command can also be a list, in a manner similar to Dockerfile : 1 command: [ \"bundle\", \"exec\", \"thin\", \"-p\", \"3000\" ] configs \u2693\ufe0e configs grant access to configs on a per-service basis using the per-service configs configuration. Two different syntax variants are supported. Compose implementations MUST report an error if config doesn't exist on platform or isn't defined in the configs section of this Compose file. There are two syntaxes defined for configs. To remain compliant to this specification, an implementation MUST support both syntaxes. Implementations MUST allow use of both short and long syntaxes within the same document. Short syntax \u2693\ufe0e The short syntax variant only specifies the config name. This grants the container access to the config and mounts it at /<config_name> within the container. The source name and destination mount point are both set to the config name. The following example uses the short syntax to grant the redis service access to the my_config and my_other_config configs. The value of my_config is set to the contents of the file ./my_config.txt , and my_other_config is defined as an external resource, which means that it has already been defined in the platform. If the external config does not exist, the deployment MUST fail. 1 2 3 4 5 6 7 8 9 10 services: redis: image: redis:latest configs: - my_config configs: my_config: file: ./my_config.txt my_other_config: external: true Long syntax \u2693\ufe0e The long syntax provides more granularity in how the config is created within the service's task containers. source : The name of the config as it exists in the platform. target : The path and name of the file to be mounted in the service's task containers. Defaults to /<source> if not specified. uid and gid : The numeric UID or GID that owns the mounted config file within the service's task containers. Default value when not specified is USER running container. mode : The permissions for the file that is mounted within the service's task containers, in octal notation. Default value is world-readable ( 0444 ). Writable bit MUST be ignored. The executable bit can be set. The following example sets the name of my_config to redis_config within the container, sets the mode to 0440 (group-readable) and sets the user and group to 103 . The redis service does not have access to the my_other_config config. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 services: redis: image: redis:latest configs: - source: my_config target: /redis_config uid: \"103\" gid: \"103\" mode: 0440 configs: my_config: external: true my_other_config: external: true You can grant a service access to multiple configs, and you can mix long and short syntax. container_name \u2693\ufe0e container_name is a string that specifies a custom container name, rather than a generated default name. 1 container_name: my-web-container Compose implementation MUST NOT scale a service beyond one container if the Compose file specifies a container_name . Attempting to do so MUST result in an error. If present, container_name SHOULD follow the regex format of [a-zA-Z0-9][a-zA-Z0-9_.-]+ credential_spec \u2693\ufe0e credential_spec configures the credential spec for a managed service account. Compose implementations that support services using Windows containers MUST support file: and registry: protocols for credential_spec. Compose implementations MAY also support additional protocols for custom use-cases. The credential_spec must be in the format file://<filename> or registry://<value-name> . 1 2 credential_spec: file: my-credential-spec.json When using registry: , the credential spec is read from the Windows registry on the daemon's host. A registry value with the given name must be located in: 1 HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Virtualization\\Containers\\CredentialSpecs The following example loads the credential spec from a value named my-credential-spec in the registry: 1 2 credential_spec: registry: my-credential-spec Example gMSA configuration \u2693\ufe0e When configuring a gMSA credential spec for a service, you only need to specify a credential spec with config , as shown in the following example: 1 2 3 4 5 6 7 8 9 services: myservice: image: myimage:latest credential_spec: config: my_credential_spec configs: my_credentials_spec: file: ./my-credential-spec.json| depends_on \u2693\ufe0e depends_on expresses startup and shutdown dependencies between services. Short syntax \u2693\ufe0e The short syntax variant only specifies service names of the dependencies. Service dependencies cause the following behaviors: Compose implementations MUST create services in dependency order. In the following example, db and redis are created before web . Compose implementations MUST remove services in dependency order. In the following example, web is removed before db and redis . Simple example: 1 2 3 4 5 6 7 8 9 10 services: web: build: . depends_on: - db - redis redis: image: redis db: image: postgres Compose implementations MUST guarantee dependency services have been started before starting a dependent service. Compose implementations MAY wait for dependency services to be \"ready\" before starting a dependent service. Long syntax \u2693\ufe0e The long form syntax enables the configuration of additional fields that can't be expressed in the short form. condition : condition under which dependency is considered satisfied service_started : is an equivalent of the short syntax described above service_healthy : specifies that a dependency is expected to be \"healthy\" (as indicated by healthcheck ) before starting a dependent service. Service dependencies cause the following behaviors: Compose implementations MUST create services in dependency order. In the following example, db and redis are created before web . Compose implementations MUST wait for healthchecks to pass on dependencies marked with service_healthy . In the following example, db is expected to be \"healthy\" before web is created. Compose implementations MUST remove services in dependency order. In the following example, web is removed before db and redis . Simple example: 1 2 3 4 5 6 7 8 9 10 11 12 services: web: build: . depends_on: db: condition: service_healthy redis: condition: service_started redis: image: redis db: image: postgres Compose implementations MUST guarantee dependency services have been started before starting a dependent service. Compose implementations MUST guarantee dependency services marked with service_healthy are \"healthy\" before starting a dependent service. device_cgroup_rules \u2693\ufe0e device_cgroup_rules defines a list of device cgroup rules for this container. The format is the same format the Linux kernel specifies in the Control Groups Device Whitelist Controller . 1 2 3 device_cgroup_rules: - 'c 1:3 mr' - 'a 7:* rmw' devices \u2693\ufe0e devices defines a list of device mappings for created containers. 1 2 devices: - \"/dev/ttyUSB0:/dev/ttyUSB0\" dns \u2693\ufe0e dns defines custom DNS servers to set on the container network interface configuration. Can be a single value or a list. 1 dns: 8.8.8.8 1 2 3 dns: - 8.8.8.8 - 9.9.9.9 dns_opt \u2693\ufe0e dns_opt list custom DNS options to be passed to the container\u2019s DNS resolver ( /etc/resolv.conf file on Linux). 1 2 3 dns_opt: - use-vc - no-tld-query dns_search \u2693\ufe0e dns defines custom DNS search domains to set on container network interface configuration. Can be a single value or a list. 1 dns_search: example.com 1 2 3 dns_search: - dc1.example.com - dc2.example.com domainname \u2693\ufe0e domainname declares a custom domain name to use for the service container. MUST be a valid RFC 1123 hostname. entrypoint \u2693\ufe0e entrypoint overrides the default entrypoint for the Docker image (i.e. ENTRYPOINT set by Dockerfile). Compose implementations MUST clear out any default command on the Docker image - both ENTRYPOINT and CMD instruction in the Dockerfile - when entrypoint is configured by a Compose file. If command is also set, it is used as parameter to entrypoint as a replacement for Docker image's CMD 1 entrypoint: /code/entrypoint.sh The entrypoint can also be a list, in a manner similar to Dockerfile : 1 2 3 4 5 6 7 entrypoint: - php - -d - zend_extension=/usr/local/lib/php/extensions/no-debug-non-zts-20100525/xdebug.so - -d - memory_limit=-1 - vendor/bin/phpunit env_file \u2693\ufe0e env_file adds environment variables to the container based on file content. 1 env_file: .env env_file can also be a list. The files in the list MUST be processed from the top down. For the same variable specified in two env files, the value from the last file in the list MUST stand. 1 2 3 env_file: - ./a.env - ./b.env Relative path MUST be resolved from the Compose file's parent folder. As absolute paths prevent the Compose file from being portable, Compose implementations SHOULD warn users when such a path is used to set env_file . Environment variables declared in the environment section MUST override these values \u2013 this holds true even if those values are empty or undefined. Env_file format \u2693\ufe0e Each line in an env file MUST be in VAR[=[VAL]] format. Lines beginning with # MUST be ignored. Blank lines MUST also be ignored. The value of VAL is used as a raw string and not modified at all. If the value is surrounded by quotes (as is often the case for shell variables), the quotes MUST be included in the value passed to containers created by the Compose implementation. VAL MAY be omitted, in such cases the variable value is empty string. =VAL MAY be omitted, in such cases the variable is unset . 1 2 3 # Set Rails/Rack environment RACK_ENV = development VAR = \"quoted\" environment \u2693\ufe0e environment defines environment variables set in the container. environment can use either an array or a map. Any boolean values; true, false, yes, no, MUST be enclosed in quotes to ensure they are not converted to True or False by the YAML parser. Environment variables MAY be declared by a single key (no value to equals sign). In such a case Compose implementations SHOULD rely on some user interaction to resolve the value. If they do not, the variable is unset and will be removed from the service container environment. Map syntax: 1 2 3 4 environment: RACK_ENV: development SHOW: \"true\" USER_INPUT: Array syntax: 1 2 3 4 environment: - RACK_ENV=development - SHOW=true - USER_INPUT When both env_file and environment are set for a service, values set by environment have precedence. expose \u2693\ufe0e expose defines the ports that Compose implementations MUST expose from container. These ports MUST be accessible to linked services and SHOULD NOT be published to the host machine. Only the internal container ports can be specified. 1 2 3 expose: - \"3000\" - \"8000\" extends \u2693\ufe0e Extend another service, in the current file or another, optionally overriding configuration. You can use extends on any service together with other configuration keys. The extends value MUST be a mapping defined with a required service and an optional file key. 1 2 3 extends : file : common.yml service : webapp If supported Compose implementations MUST process extends in the following way: service defines the name of the service being referenced as a base, for example web or database . file is the location of a Compose configuration file defining that service. Restrictions \u2693\ufe0e The following restrictions apply to the service being referenced: Services that have dependencies on other services cannot be used as a base. Therefore, any key that introduces a dependency on another service is incompatible with extends . The non-exhaustive list of such keys is: links , volumes_from , container mode (in ipc , pid , network_mode and net ), service mode (in ipc , pid and network_mode ), depends_on . Services cannot have circular references with extends Compose implementations MUST return an error in all of these cases. Finding referenced service \u2693\ufe0e file value can be: Not present. This indicates that another service within the same Compose file is being referenced. File path, which can be either: Relative path. This path is considered as relative to the location of the main Compose file. Absolute path. Service denoted by service MUST be present in the identified referenced Compose file. Compose implementations MUST return an error if: Service denoted by service was not found Compose file denoted by file was not found Merging service definitions \u2693\ufe0e Two service definitions ( main one in the current Compose file and referenced one specified by extends ) MUST be merged in the following way: Mappings: keys in mappings of main service definition override keys in mappings of referenced service definition. Keys that aren't overridden are included as is. Sequences: items are combined together into an new sequence. Order of elements is preserved with the referenced items coming first and main items after. Scalars: keys in main service definition take precedence over keys in the referenced one. Mappings \u2693\ufe0e The following keys should be treated as mappings: build.args , build.labels , build.extra_hosts , deploy.labels , deploy.update_config , deploy.rollback_config , deploy.restart_policy , deploy.resources.limits , environment , healthcheck , labels , logging.options , sysctls , storage_opt , extra_hosts , ulimits . One exception that applies to healthcheck is that main mapping cannot specify disable: true unless referenced mapping also specifies disable: true . Compose implementations MUST return an error in this case. For example, the input below: 1 2 3 4 5 6 7 8 9 10 11 services : common : image : busybox environment : TZ : utc PORT : 80 cli : extends : service : common environment : PORT : 8080 Produces the following configuration for the cli service. The same output is produced if array syntax is used. 1 2 3 4 environment : PORT : 8080 TZ : utc image : busybox Items under blkio_config.device_read_bps , blkio_config.device_read_iops , blkio_config.device_write_bps , blkio_config.device_write_iops , devices and volumes are also treated as mappings where key is the target path inside the container. For example, the input below: 1 2 3 4 5 6 7 8 9 10 services : common : image : busybox volumes : - common-volume:/var/lib/backup/data:rw cli : extends : service : common volumes : - cli-volume:/var/lib/backup/data:ro Produces the following configuration for the cli service. Note that mounted path now points to the new volume name and ro flag was applied. 1 2 3 image : busybox volumes : - cli-volume:/var/lib/backup/data:ro If referenced service definition contains extends mapping, the items under it are simply copied into the new merged definition. Merging process is then kicked off again until no extends keys are remaining. For example, the input below: 1 2 3 4 5 6 7 8 9 10 11 services : base : image : busybox user : root common : image : busybox extends : service : base cli : extends : service : common Produces the following configuration for the cli service. Here, cli services gets user key from common service, which in turn gets this key from base service. 1 2 image : busybox user : root Sequences \u2693\ufe0e The following keys should be treated as sequences: cap_add , cap_drop , configs , deploy.placement.constraints , deploy.placement.preferences , deploy.reservations.generic_resources , device_cgroup_rules , expose , external_links , ports , secrets , security_opt . Any duplicates resulting from the merge are removed so that the sequence only contains unique elements. For example, the input below: 1 2 3 4 5 6 7 8 9 10 services : common : image : busybox security_opt : - label:role:ROLE cli : extends : service : common security_opt : - label:user:USER Produces the following configuration for the cli service. 1 2 3 4 image : busybox security_opt : - label:role:ROLE - label:user:USER In case list syntax is used, the following keys should also be treated as sequences: dns , dns_search , env_file , tmpfs . Unlike sequence fields mentioned above, duplicates resulting from the merge are not removed. Scalars \u2693\ufe0e Any other allowed keys in the service definition should be treated as scalars. external_links \u2693\ufe0e external_links link service containers to services managed outside this Compose application. external_links define the name of an existing service to retrieve using the platform lookup mechanism. An alias of the form SERVICE:ALIAS can be specified. 1 2 3 4 external_links: - redis - database:mysql - database:postgresql extra_hosts \u2693\ufe0e extra_hosts adds hostname mappings to the container network interface configuration ( /etc/hosts for Linux). Values MUST set hostname and IP address for additional hosts in the form of HOSTNAME:IP . 1 2 3 extra_hosts: - \"somehost:162.242.195.82\" - \"otherhost:50.31.209.229\" Compose implementations MUST create matching entry with the IP address and hostname in the container's network configuration, which means for Linux /etc/hosts will get extra lines: 1 2 162.242.195.82 somehost 50.31.209.229 otherhost group_add \u2693\ufe0e group_add specifies additional groups (by name or number) which the user inside the container MUST be a member of. An example of where this is useful is when multiple containers (running as different users) need to all read or write the same file on a shared volume. That file can be owned by a group shared by all the containers, and specified in group_add . 1 2 3 4 5 services: myservice: image: alpine group_add: - mail Running id inside the created container MUST show that the user belongs to the mail group, which would not have been the case if group_add were not declared. healthcheck \u2693\ufe0e healthcheck declares a check that's run to determine whether or not containers for this service are \"healthy\". This overrides HEALTHCHECK Dockerfile instruction set by the service's Docker image. 1 2 3 4 5 6 healthcheck: test: [\"CMD\", \"curl\", \"-f\", \"http://localhost\"] interval: 1m30s timeout: 10s retries: 3 start_period: 40s interval , timeout and start_period are specified as durations . test defines the command the Compose implementation will run to check container health. It can be either a string or a list. If it's a list, the first item must be either NONE , CMD or CMD-SHELL . If it's a string, it's equivalent to specifying CMD-SHELL followed by that string. 1 2 # Hit the local web app test: [\"CMD\", \"curl\", \"-f\", \"http://localhost\"] Using CMD-SHELL will run the command configured as a string using the container's default shell ( /bin/sh for Linux). Both forms below are equivalent: 1 test: [\"CMD-SHELL\", \"curl -f http://localhost || exit 1\"] 1 test: curl -f https://localhost || exit 1 NONE disable the healthcheck, and is mostly useful to disable Healthcheck set by image. Alternatively the healthcheck set by the image can be disabled by setting disable: true : 1 2 healthcheck: disable: true hostname \u2693\ufe0e hostname declares a custom host name to use for the service container. MUST be a valid RFC 1123 hostname. image \u2693\ufe0e image specifies the image to start the container from. Image MUST follow the Open Container Specification addressable image format , as [<registry>/][<project>/]<image>[:<tag>|@<digest>] . 1 2 3 4 5 6 image: redis image: redis:5 image: redis@sha356:0ed5d5928d4737458944eb604cc8509e245c3e19d02ad83935398bc4b991aac7 image: library/redis image: docker.io/library/redis image: my_private.registry:5000/redis If the image does not exist on the platform, Compose implementations MUST attempt to pull it based on the pull_policy . Compose implementations with build support MAY offer alternative options for the end user to control precedence of pull over building the image from source, however pulling the image MUST be the default behavior. image MAY be omitted from a Compose file as long as a build section is declared. Compose implementations without build support MUST fail when image is missing from the Compose file. init \u2693\ufe0e init run an init process (PID 1) inside the container that forwards signals and reaps processes. Set this option to true to enable this feature for the service. 1 2 3 4 services: web: image: alpine:latest init: true The init binary that is used is platform specific. ipc \u2693\ufe0e ipc configures the IPC isolation mode set by service container. Available values are platform specific, but Compose specification defines specific values which MUST be implemented as described if supported: shareable which gives the container own private IPC namespace, with a possibility to share it with other containers. service:{name} which makes the container join another ( shareable ) container's IPC namespace. 1 2 ipc: \"shareable\" ipc: \"service:[service name]\" isolation \u2693\ufe0e isolation specifies a container\u2019s isolation technology. Supported values are platform-specific. labels \u2693\ufe0e labels add metadata to containers. You can use either an array or a map. It's recommended that you use reverse-DNS notation to prevent your labels from conflicting with those used by other software. 1 2 3 4 labels: com.example.description: \"Accounting webapp\" com.example.department: \"Finance\" com.example.label-with-empty-value: \"\" 1 2 3 4 labels: - \"com.example.description=Accounting webapp\" - \"com.example.department=Finance\" - \"com.example.label-with-empty-value\" Compose implementations MUST create containers with canonical labels: com.docker.compose.project set on all resources created by Compose implementation to the user project name com.docker.compose.service set on service containers with service name as defined in the Compose file The com.docker.compose label prefix is reserved. Specifying labels with this previx in the Compose file MUST result in a runtime error. links \u2693\ufe0e links defines a network link to containers in another service. Either specify both the service name and a link alias ( SERVICE:ALIAS ), or just the service name. 1 2 3 4 5 web: links: - db - db:database - redis Containers for the linked service MUST be reachable at a hostname identical to the alias, or the service name if no alias was specified. Links are not required to enable services to communicate - when no specific network configuration is set, any service MUST be able to reach any other service at that service\u2019s name on the default network. If services do declare networks they are attached to, links SHOULD NOT override the network configuration and services not attached to a shared network SHOULD NOT be able to communicate. Compose implementations MAY NOT warn the user about this configuration mismatch. Links also express implicit dependency between services in the same way as depends_on , so they determine the order of service startup. logging \u2693\ufe0e logging defines the logging configuration for the service. 1 2 3 4 logging: driver: syslog options: syslog-address: \"tcp://192.168.0.42:123\" The driver name specifies a logging driver for the service's containers. The default and available values are platform specific. Driver specific options can be set with options as key-value pairs. network_mode \u2693\ufe0e network_mode set service containers network mode. Available values are platform specific, but Compose specification define specific values which MUST be implemented as described if supported: none which disable all container networking host which gives the container raw access to host's network interface service:{name} which gives the containers access to the specified service only 1 2 3 network_mode: \"host\" network_mode: \"none\" network_mode: \"service:[service name]\" networks \u2693\ufe0e networks defines the networks that service containers are attached to, referencing entries under the top-level networks key . 1 2 3 4 5 services: some-service: networks: - some-network - other-network aliases \u2693\ufe0e aliases declares alternative hostnames for this service on the network. Other containers on the same network can use either the service name or this alias to connect to one of the service's containers. Since aliases are network-scoped, the same service can have different aliases on different networks. Note : A network-wide alias can be shared by multiple containers, and even by multiple services. If it is, then exactly which container the name resolves to is not guaranteed. The general format is shown here: 1 2 3 4 5 6 7 8 9 10 services: some-service: networks: some-network: aliases: - alias1 - alias3 other-network: aliases: - alias2 In the example below, service frontend will be able to reach the backend service at the hostname backend or database on the back-tier network, and service monitoring will be able to reach same backend service at db or mysql on the admin network. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 services: frontend: image: awesome/webapp networks: - front-tier - back-tier monitoring: image: awesome/monitoring networks: - admin backend: image: awesome/backend networks: back-tier: aliases: - database admin: aliases: - mysql networks: front-tier: back-tier: admin: ipv4_address, ipv6_address \u2693\ufe0e Specify a static IP address for containers for this service when joining the network. The corresponding network configuration in the top-level networks section MUST have an ipam block with subnet configurations covering each static address. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 services: frontend: image: awesome/webapp networks: front-tier: ipv4_address: 172.16.238.10 ipv6_address: 2001:3984:3989::10 networks: front-tier: ipam: driver: default config: - subnet: \"172.16.238.0/24\" - subnet: \"2001:3984:3989::/64\" link_local_ips \u2693\ufe0e link_local_ips specifies a list of link-local IPs. Link-local IPs are special IPs which belong to a well known subnet and are purely managed by the operator, usually dependent on the architecture where they are deployed. Implementation is Platform specific. Example: 1 2 3 4 5 6 7 8 9 10 11 12 services : app : image : busybox command : top networks : app_net : link_local_ips : - 57.123.22.11 - 57.123.22.13 networks : app_net : driver : bridge priority \u2693\ufe0e priority indicates in which order Compose implementation SHOULD connect the service\u2019s containers to its networks. If unspecified, the default value is 0. In the following example, the app service connects to app_net_1 first as it has the highest priority. It then connects to app_net_3, then app_net_2, which uses the default priority value of 0. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 services : app : image : busybox command : top networks : app_net_1 : priority : 1000 app_net_2 : app_net_3 : priority : 100 networks : app_net_1 : app_net_2 : app_net_3 : mac_address \u2693\ufe0e mac_address sets a MAC address for service container. mem_limit \u2693\ufe0e DEPRECATED: use deploy.limits.memory mem_reservation \u2693\ufe0e DEPRECATED: use deploy.reservations.memory mem_swappiness \u2693\ufe0e mem_swappiness defines as a percentage (a value between 0 and 100) for the host kernel to swap out anonymous memory pages used by a container. a value of 0 turns off anonymous page swapping. a value of 100 sets all anonymous pages as swappable. Default value is platform specific. memswap_limit \u2693\ufe0e memswap_limit defines the amount of memory container is allowed to swap to disk. This is a modifier attribute that only has meaning if memory is also set. Using swap allows the container to write excess memory requirements to disk when the container has exhausted all the memory that is available to it. There is a performance penalty for applications that swap memory to disk often. If memswap_limit is set to a positive integer, then both memory and memswap_limit MUST be set. memswap_limit represents the total amount of memory and swap that can be used, and memory controls the amount used by non-swap memory. So if memory =\"300m\" and memswap_limit =\"1g\", the container can use 300m of memory and 700m (1g - 300m) swap. If memswap_limit is set to 0, the setting MUST be ignored, and the value is treated as unset. If memswap_limit is set to the same value as memory , and memory is set to a positive integer, the container does not have access to swap. See Prevent a container from using swap. If memswap_limit is unset, and memory is set, the container can use as much swap as the memory setting, if the host container has swap memory configured. For instance, if memory =\"300m\" and memswap_limit is not set, the container can use 600m in total of memory and swap. If memswap_limit is explicitly set to -1, the container is allowed to use unlimited swap, up to the amount available on the host system. oom_kill_disable \u2693\ufe0e If oom_kill_disable is set Compose implementation MUST configure the platform so it won't kill the container in case of memory starvation. oom_score_adj \u2693\ufe0e oom_score_adj tunes the preference for containers to be killed by platform in case of memory starvation. Valu MUST be within [-1000,1000] range. pid \u2693\ufe0e pid sets the PID mode for container created by the Compose implementation. Supported values are platform specific. pid_limit \u2693\ufe0e pid_limit tunes a container\u2019s PIDs limit. Set to -1 for unlimited PIDs. 1 pids_limit: 10 platform \u2693\ufe0e platform defines the target platform containers for this service will run on, using the os[/arch[/variant]] syntax. Compose implementation MUST use this attribute when declared to determine which version of the image will be pulled and/or on which platform the service\u2019s build will be performed. 1 2 3 platform: osx platform: windows/amd64 platform: linux/arm64/v8 ports \u2693\ufe0e Exposes container ports. Port mapping MUST NOT be used with network_mode: host and doing so MUST result in a runtime error. Short syntax \u2693\ufe0e The short syntax is a comma-separated string to set host IP, host port and container port in the form: [HOST:]CONTAINER[/PROTOCOL] where: HOST is [IP:](port | range) CONTAINER is port | range PROTOCOL to restrict port to specified protocol. tcp and udp values are defined by the specification, Compose implementations MAY offer support for platform-specific protocol names. Host IP, if not set, MUST bind to all network interfaces. Port can be either a single value or a range. Host and container MUST use equivalent ranges. Either specify both ports ( HOST:CONTAINER ), or just the container port. In the latter case, the Compose implementation SHOULD automatically allocate and unassigned host port. HOST:CONTAINER SHOULD always be specified as a (quoted) string, to avoid conflicts with yaml base-60 float . Samples: 1 2 3 4 5 6 7 8 9 ports: - \"3000\" - \"3000-3005\" - \"8000:8000\" - \"9090-9091:8080-8081\" - \"49100:22\" - \"127.0.0.1:8001:8001\" - \"127.0.0.1:5000-5010:5000-5010\" - \"6060:6060/udp\" Note : Host IP mapping MAY not be supported on the platform, in such case Compose implementations SHOULD reject the Compose file and MUST inform the user they will ignore the specified host IP. Long syntax \u2693\ufe0e The long form syntax allows the configuration of additional fields that can't be expressed in the short form. target : the container port published : the publicly exposed port protocol : the port protocol ( tcp or udp ), unspecified means any protocol mode : host for publishing a host port on each node, or ingress for a port to be load balanced. 1 2 3 4 5 ports: - target: 80 published: 8080 protocol: tcp mode: host privileged \u2693\ufe0e privileged configures the service container to run with elevated privileges. Support and actual impacts are platform-specific. profiles \u2693\ufe0e profiles defines a list of named profiles for the service to be enabled under. When not set, service is always enabled. If present, profiles SHOULD follow the regex format of [a-zA-Z0-9][a-zA-Z0-9_.-]+ . pull_policy \u2693\ufe0e pull_policy defines the decisions Compose implementations will make when it starts to pull images. Possible values are: always : Compose implementations SHOULD always pull the image from the registry. never : Compose implementations SHOULD NOT pull the image from a registry and SHOULD rely on the platform cached image. If there is no cached image, a failure MUST be reported. if_not_present : Compose implementations SHOULD pull the image only if it's not available in the platform cache.This SHOULD be the default option for Compose implementations without build support. build : Compose implementations SHOULD build the image. Compose implementations SHOULD rebuild the image if already present. If pull_policy and build both presents, Compose implementations SHOULD build the image by default. Compose implementations MAY override this behavior in the toolchain. read_only \u2693\ufe0e read_only configures service container to be created with a read-only filesystem. restart \u2693\ufe0e restart defines the policy that the platform will apply on container termination. no : The default restart policy. Does not restart a container under any circumstances. always : The policy always restarts the container until its removal. on-failure : The policy restarts a container if the exit code indicates an error. unless-stopped : The policy restarts a container irrespective of the exit code but will stop restarting when the service is stopped or removed. 1 2 3 4 restart: \"no\" restart: always restart: on-failure restart: unless-stopped runtime \u2693\ufe0e DEPRECATED: this attribute is low-level platform implementation detail runtime specifies which runtime to use for the service\u2019s containers. 1 2 3 4 web: image: busybox:latest command: true runtime: runc scale \u2693\ufe0e -DEPRECATED: use deploy/replicas _ scale specifies the default number of containers to deploy for this service. secrets \u2693\ufe0e secrets grants access to sensitive data defined by secrets on a per-service basis. Two different syntax variants are supported: the short syntax and the long syntax. Compose implementations MUST report an error if the secret doesn't exist on the platform or isn't defined in the secrets section of this Compose file. Short syntax \u2693\ufe0e The short syntax variant only specifies the secret name. This grants the container access to the secret and mounts it as read-only to /run/secrets/<secret_name> within the container. The source name and destination mountpoint are both set to the secret name. The following example uses the short syntax to grant the frontend service access to the server-certificate secret. The value of server-certificate is set to the contents of the file ./server.cert . 1 2 3 4 5 6 7 8 services: frontend: image: awesome/webapp secrets: - server-certificate secrets: server-certificate: file: ./server.cert Long syntax \u2693\ufe0e The long syntax provides more granularity in how the secret is created within the service's containers. source : The name of the secret as it exists on the platform. target : The name of the file to be mounted in /run/secrets/ in the service's task containers. Defaults to source if not specified. uid and gid : The numeric UID or GID that owns the file within /run/secrets/ in the service's task containers. Default value is USER running container. mode : The permissions for the file to be mounted in /run/secrets/ in the service's task containers, in octal notation. Default value is world-readable permissions (mode 0444 ). The writable bit MUST be ignored if set. The executable bit MAY be set. The following example sets the name of the server-certificate secret file to server.crt within the container, sets the mode to 0440 (group-readable) and sets the user and group to 103 . The value of server-certificate secret is provided by the platform through a lookup and the secret lifecycle not directly managed by the Compose implementation. 1 2 3 4 5 6 7 8 9 10 11 12 services: frontend: image: awesome/webapp secrets: - source: server-certificate target: server.cert uid: \"103\" gid: \"103\" mode: 0440 secrets: server-certificate: external: true Services MAY be granted access to multiple secrets. Long and short syntax for secrets MAY be used in the same Compose file. Defining a secret in the top-level secrets MUTS NOT imply granting any service access to it. Such grant must be explicit within service specification as secrets service element. security_opt \u2693\ufe0e security_opt overrides the default labeling scheme for each container. 1 2 3 security_opt: - label:user:USER - label:role:ROLE shm_size \u2693\ufe0e shm_size configures the size of the shared memory ( /dev/shm partition on Linux) allowed by the service container. Specified as a byte value . stdin_open \u2693\ufe0e stdin_open configures service containers to run with an allocated stdin. stop_grace_period \u2693\ufe0e stop_grace_period specifies how long the Compose implementation MUST wait when attempting to stop a container if it doesn't handle SIGTERM (or whichever stop signal has been specified with stop_signal ), before sending SIGKILL. Specified as a duration . 1 2 stop_grace_period: 1s stop_grace_period: 1m30s Default value is 10 seconds for the container to exit before sending SIGKILL. stop_signal \u2693\ufe0e stop_signal defines the signal that the Compose implementation MUST use to stop the service containers. If unset containers are stopped by the Compose Implementation by sending SIGTERM . 1 stop_signal: SIGUSR1 sysctls \u2693\ufe0e sysctls defines kernel parameters to set in the container. sysctls can use either an array or a map. 1 2 3 sysctls: net.core.somaxconn: 1024 net.ipv4.tcp_syncookies: 0 1 2 3 sysctls: - net.core.somaxconn=1024 - net.ipv4.tcp_syncookies=0 You can only use sysctls that are namespaced in the kernel. Docker does not support changing sysctls inside a container that also modify the host system. For an overview of supported sysctls, refer to configure namespaced kernel parameters (sysctls) at runtime . tmpfs \u2693\ufe0e tmpfs mounts a temporary file system inside the container. Can be a single value or a list. 1 tmpfs: /run 1 2 3 tmpfs: - /run - /tmp tty \u2693\ufe0e tty configure service container to run with a TTY. ulimits \u2693\ufe0e ulimits overrides the default ulimits for a container. Either specifies as a single limit as an integer or soft/hard limits as a mapping. 1 2 3 4 5 ulimits: nproc: 65535 nofile: soft: 20000 hard: 40000 user \u2693\ufe0e user overrides the user used to run the container process. Default is that set by image (i.e. Dockerfile USER ), if not set, root . userns_mode \u2693\ufe0e userns_mode sets the user namespace for the service. Supported values are platform specific and MAY depend on platform configuration 1 userns_mode: \"host\" volumes \u2693\ufe0e volumes defines mount host paths or named volumes that MUST be accessible by service containers. If the mount is a host path and only used by a single service, it MAY be declared as part of the service definition instead of the top-level volumes key. To reuse a volume across multiple services, a named volume MUST be declared in the top-level volumes key . This example shows a named volume ( db-data ) being used by the backend service, and a bind mount defined for a single service 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 services: backend: image: awesome/backend volumes: - type: volume source: db-data target: /data volume: nocopy: true - type: bind source: /var/run/postgres/postgres.sock target: /var/run/postgres/postgres.sock volumes: db-data: Short syntax \u2693\ufe0e The short syntax uses a single string with comma-separated values to specify a volume mount ( VOLUME:CONTAINER_PATH ), or an access mode ( VOLUME:CONTAINER:ACCESS_MODE ). VOLUME MAY be either a host path on the platform hosting containers (bind mount) or a volume name. ACCESS_MODE MAY be set as read-only by using ro or read and write by using rw (default). Note : Relative host paths MUST only be supported by Compose implementations that deploy to a local container runtime. This is because the relative path is resolved from the Compose file\u2019s parent directory which is only applicable in the local case. Compose Implementations deploying to a non-local platform MUST reject Compose files which use relative host paths with an error. To avoid ambiguities with named volumes, relative paths SHOULD always begin with . or .. . Long syntax \u2693\ufe0e The long form syntax allows the configuration of additional fields that can't be expressed in the short form. type : the mount type volume , bind , tmpfs or npipe source : the source of the mount, a path on the host for a bind mount, or the name of a volume defined in the top-level volumes key . Not applicable for a tmpfs mount. target : the path in the container where the volume is mounted read_only : flag to set the volume as read-only bind : configure additional bind options propagation : the propagation mode used for the bind volume : configure additional volume options nocopy : flag to disable copying of data from a container when a volume is created tmpfs : configure additional tmpfs options size : the size for the tmpfs mount in bytes consistency : the consistency requirements of the mount. Available values are platform specific volumes_from \u2693\ufe0e volumes_from mounts all of the volumes from another service or container, optionally specifying read-only access (ro) or read-write (rw). If no access level is specified, then read-write MUST be used. String value defines another service in the Compose application model to mount volumes from. The container: prefix, if supported, allows to mount volumes from a container that is not managed by the Compose implementation. 1 2 3 4 5 volumes_from : - service_name - service_name:ro - container:container_name - container:container_name:rw working_dir \u2693\ufe0e working_dir overrides the container's working directory from that specified by image (i.e. Dockerfile WORKDIR ). Networks top-level element \u2693\ufe0e Networks are the layer that allow services to communicate with each other. The networking model exposed to a service is limited to a simple IP connection with target services and external resources, while the Network definition allows fine-tuning the actual implementation provided by the platform. Networks can be created by specifying the network name under a top-level networks section. Services can connect to networks by specifying the network name under the service networks subsection In the following example, at runtime, networks front-tier and back-tier will be created and the frontend service connected to the front-tier network and the back-tier network. 1 2 3 4 5 6 7 8 9 10 services: frontend: image: awesome/webapp networks: - front-tier - back-tier networks: front-tier: back-tier: driver \u2693\ufe0e driver specifies which driver should be used for this network. Compose implementations MUST return an error if the driver is not available on the platform. 1 driver: overlay Default and available values are platform specific. Compose specification MUST support the following specific drivers: none and host host use the host's networking stack none disable networking host or none \u2693\ufe0e The syntax for using built-in networks such as host and none is different, as such networks implicitly exists outside the scope of the Compose implementation. To use them one MUST define an external network with the name host or none and an alias that the Compose implementation can use ( hostnet or nonet in the following examples), then grant the service access to that network using its alias. 1 2 3 4 5 6 7 8 9 services: web: networks: hostnet: {} networks: hostnet: external: true name: host 1 2 3 4 5 6 7 8 9 10 services: web: ... networks: nonet: {} networks: nonet: external: true name: none driver_opts \u2693\ufe0e driver_opts specifies a list of options as key-value pairs to pass to the driver for this network. These options are driver-dependent - consult the driver's documentation for more information. Optional. 1 2 3 driver_opts: foo: \"bar\" baz: 1 attachable \u2693\ufe0e If attachable is set to true , then standalone containers SHOULD be able attach to this network, in addition to services. If a standalone container attaches to the network, it can communicate with services and other standalone containers that are also attached to the network. 1 2 3 4 networks: mynet1: driver: overlay attachable: true enable_ipv6 \u2693\ufe0e enable_ipv6 enable IPv6 networking on this network. ipam \u2693\ufe0e ipam specifies custom a IPAM configuration. This is an object with several properties, each of which is optional: driver : Custom IPAM driver, instead of the default. config : A list with zero or more configuration elements, each containing: subnet : Subnet in CIDR format that represents a network segment ip_range : Range of IPs from which to allocate container IPs gateway : IPv4 or IPv6 gateway for the master subnet aux_addresses : Auxiliary IPv4 or IPv6 addresses used by Network driver, as a mapping from hostname to IP options : Driver-specific options as a key-value mapping. A full example: 1 2 3 4 5 6 7 8 9 10 11 12 13 ipam: driver: default config: - subnet: 172.28.0.0/16 ip_range: 172.28.5.0/24 gateway: 172.28.5.254 aux_addresses: host1: 172.28.1.5 host2: 172.28.1.6 host3: 172.28.1.7 options: foo: bar baz: \"0\" internal \u2693\ufe0e By default, Compose implementations MUST provides external connectivity to networks. internal when set to true allow to create an externally isolated network. labels \u2693\ufe0e Add metadata to containers using Labels. Can use either an array or a dictionary. Users SHOULD use reverse-DNS notation to prevent labels from conflicting with those used by other software. 1 2 3 4 labels: com.example.description: \"Financial transaction network\" com.example.department: \"Finance\" com.example.label-with-empty-value: \"\" 1 2 3 4 labels: - \"com.example.description=Financial transaction network\" - \"com.example.department=Finance\" - \"com.example.label-with-empty-value\" Compose implementations MUST set com.docker.compose.project and com.docker.compose.network labels. external \u2693\ufe0e If set to true , external specifies that this network\u2019s lifecycle is maintained outside of that of the application. Compose Implementations SHOULD NOT attempt to create these networks, and raises an error if one doesn't exist. In the example below, proxy is the gateway to the outside world. Instead of attempting to create a network, Compose implementations SHOULD interrogate the platform for an existing network simply called outside and connect the proxy service's containers to it. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 services: proxy: image: awesome/proxy networks: - outside - default app: image: awesome/app networks: - default networks: outside: external: true name \u2693\ufe0e name sets a custom name for this network. The name field can be used to reference networks which contain special characters. The name is used as is and will not be scoped with the project name. 1 2 3 networks: network1: name: my-app-net It can also be used in conjunction with the external property to define the platform network that the Compose implementation should retrieve, typically by using a parameter so the Compose file doesn't need to hard-code runtime specific values: 1 2 3 4 networks: network1: external: true name: \"${NETWORK_ID}\" Volumes top-level element \u2693\ufe0e Volumes are persistent data stores implemented by the platform. The Compose specification offers a neutral abstraction for services to mount volumes, and configuration parameters to allocate them on infrastructure. The volumes section allows the configuration of named volumes that can be reused across multiple services. Here's an example of a two-service setup where a database's data directory is shared with another service as a volume so that it can be periodically backed up: 1 2 3 4 5 6 7 8 9 10 11 12 13 services: backend: image: awesome/database volumes: - db-data:/etc/data backup: image: backup-service volumes: - db-data:/var/lib/backup/data volumes: db-data: An entry under the top-level volumes key can be empty, in which case it uses the platform's default configuration for creating a volume. Optionally, you can configure it with the following keys: driver \u2693\ufe0e Specify which volume driver should be used for this volume. Default and available values are platform specific. If the driver is not available, the Compose implementation MUST return an error and stop application deployment. 1 driver: foobar driver_opts \u2693\ufe0e driver_opts specifies a list of options as key-value pairs to pass to the driver for this volume. Those options are driver-dependent. 1 2 3 4 5 6 volumes: example: driver_opts: type: \"nfs\" o: \"addr=10.40.0.199,nolock,soft,rw\" device: \":/docker/example\" external \u2693\ufe0e If set to true , external specifies that this volume already exist on the platform and its lifecycle is managed outside of that of the application. Compose implementations MUST NOT attempt to create these volumes, and MUST return an error they do not exist. In the example below, instead of attempting to create a volume called {project_name}_data , Compose looks for an existing volume simply called data and mount it into the db service's containers. 1 2 3 4 5 6 7 8 9 services: backend: image: awesome/database volumes: - db-data:/etc/data volumes: db-data: external: true labels \u2693\ufe0e labels are used to add metadata to volumes. You can use either an array or a dictionary. It's recommended that you use reverse-DNS notation to prevent your labels from conflicting with those used by other software. 1 2 3 4 labels: com.example.description: \"Database volume\" com.example.department: \"IT/Ops\" com.example.label-with-empty-value: \"\" 1 2 3 4 labels: - \"com.example.description=Database volume\" - \"com.example.department=IT/Ops\" - \"com.example.label-with-empty-value\" Compose implementation MUST set com.docker.compose.project and com.docker.compose.volmume labels. name \u2693\ufe0e name set a custom name for this volume. The name field can be used to reference volumes that contain special characters. The name is used as is and will not be scoped with the stack name. 1 2 3 volumes: data: name: \"my-app-data\" It can also be used in conjunction with the external property. Doing so the name of the volume used to lookup for actual volume on platform is set separately from the name used to refer to it within the Compose file: 1 2 3 4 volumes: db-data: external: name: actual-name-of-volume This make it possible to make this lookup name a parameter of a Compose file, so that the model ID for volume is hard-coded but the actual volume ID on platform is set at runtime during deployment: 1 2 3 4 volumes: db-data: external: name: ${DATABASE_VOLUME} Configs top-level element \u2693\ufe0e Configs allow services to adapt their behaviour without the need to rebuild a Docker image. Configs are comparable to Volumes from a service point of view as they are mounted into service's containers filesystem. The actual implementation detail to get configuration provided by the platform can be set from the Configuration definition. When granted accessto a config, the config content is mounted as a file in the container. The location of the mount point within the container defaults to /<config-name> in Linux containers and C:\\<config-name> in Windows containers. By default, the config MUST be owned by the user running the container command but can be overriden by service configuration. By default, the config MUST have world-readable permissions (mode 0444), unless service is configured to override this. Services can only access configs when explicitly granted by a configs subsection. The top-level configs declaration defines or references configuration data that can be granted to the services in this application. The source of the config is either file or external . file : The config is created with the contents of the file at the specified path. external : If set to true, specifies that this config has already been created. Compose implementation does not attempt to create it, and if it does not exist, an error occurs. name : The name of config object on Platform to lookup. This field can be used to reference configs that contain special characters. The name is used as is and will not be scoped with the project name. In this example, http_config is created (as <project_name>_http_config) when the application is deployed, and my_second_config MUST already exists on Platform and value will be obtained by lookup. In this example, server-http_config is created as <project_name>_http_config when the application is deployed, by registering content of the httpd.conf as configuration data. 1 2 3 configs: http_config: file: ./httpd.conf Alternatively, http_config can be declared as external, doing so Compose implementation will lookup server-certificate to expose configuration data to relevant services. 1 2 3 configs: http_config: external: true External configs lookup can also use a distinct key by specifying a name . The following example modifies the previous one to lookup for config using a parameter HTTP_CONFIG_KEY . Doing so the actual lookup key will be set at deployment time by interpolation of variables, but exposed to containers as hard-coded ID http_config . 1 2 3 4 configs: http_config: external: true name: \"${HTTP_CONFIG_KEY}\" Compose file need to explicitly grant access to the configs to relevant services in the application. Secrets top-level element \u2693\ufe0e Secrets are a flavour of Configs focussing on sensitive data, with specific constraint for this usage. As the platform implementation may significally differ from Configs, dedicated Secrets section allows to configure the related resources. The top-level secrets declaration defines or references sensitive data that can be granted to the services in this application. The source of the secret is either file or external . file : The secret is created with the contents of the file at the specified path. external : If set to true, specifies that this secret has already been created. Compose implementation does not attempt to create it, and if it does not exist, an error occurs. name : The name of the secret object in Docker. This field can be used to reference secrets that contain special characters. The name is used as is and will not be scoped with the project name. In this example, server-certificate is created as <project_name>_server-certificate when the application is deployed, by registering content of the server.cert as a platform secret. 1 2 3 secrets: server-certificate: file: ./server.cert Alternatively, server-certificate can be declared as external, doing so Compose implementation will lookup server-certificate to expose secret to relevant services. 1 2 3 secrets: server-certificate: external: true External secrets lookup can also use a distinct key by specifying a name . The following example modifies the previous one to look up for secret using a parameter CERTIFICATE_KEY . Doing so the actual lookup key will be set at deployment time by interpolation of variables, but exposed to containers as hard-coded ID server-certificate . 1 2 3 4 secrets: server-certificate: external: true name: \"${CERTIFICATE_KEY}\" Compose file need to explicitly grant access to the secrets to relevant services in the application. Fragments \u2693\ufe0e It is possible to re-use configuration fragments using YAML anchors . 1 2 3 4 volumes: db-data: &default-volume driver: default metrics: *default-volume In previous sample, an anchor is created as default-volume based on db-data volume specification. It is later reused by alias *default-volume to define metrics volume. Same logic can apply to any element in a Compose file. Anchor resolution MUST take place before variables interpolation , so variables can't be used to set anchors or aliases. It is also possible to partially override values set by anchor reference using the YAML merge type . In following example, metrics volume specification uses alias to avoid repetition but override name attribute: 1 2 3 4 5 6 7 8 9 10 11 12 13 services: backend: image: awesome/database volumes: - db-data - metrics volumes: db-data: &default-volume driver: default name: \"data\" metrics: <<: *default-volume name: \"metrics\" Extension \u2693\ufe0e Special extension fields can be of any format as long as their name starts with the x- character sequence. They can be used within any structure in a Compose file. This is the sole exception for Compose implementations to silently ignore unrecognized field. 1 2 3 4 5 6 7 8 9 x-custom: foo: - bar - zot services: webapp: image: awesome/webapp x-foo: bar The contents of such fields are unspecified by Compose specification, and can be used to enable custom features. Compose implementation to encounter an unknown extension field MUST NOT fail, but COULD warn about unknown field. For platform extensions, it is highly recommended to prefix extension by platform/vendor name, the same way browsers add support for custom CSS features 1 2 3 4 5 6 7 service: backend: deploy: placement: x-aws-role: \"arn:aws:iam::XXXXXXXXXXXX:role/foo\" x-aws-region: \"eu-west-3\" x-azure-region: \"france-central\" Informative Historical Notes \u2693\ufe0e This section is informative. At the time of writing, the following prefixes are known to exist: prefix vendor/organization docker Docker kubernetes Kubernetes Using extensions as fragments \u2693\ufe0e With the support for extension fields, Compose file can be written as follows to improve readability of reused fragments: 1 2 3 4 5 6 7 8 9 10 11 12 13 x-logging: &default-logging options: max-size: \"12m\" max-file: \"5\" driver: json-file services: frontend: image: awesome/webapp logging: *default-logging backend: image: awesome/database logging: *default-logging specifying- byte values \u2693\ufe0e Value express a byte value as a string in {amount}{byte unit} format: The supported units are b (bytes), k or kb (kilo bytes), m or mb (mega bytes) and g or gb (giga bytes). 1 2 3 4 5 2b 1024kb 2048k 300m 1gb specifying durations \u2693\ufe0e Value express a duration as a string in thte in the form of {value}{unit} . The supported units are us (microseconds), ms (milliseconds), s (seconds), m (minutes) and h (hours). Value can can combine mutiple values and using without separator. 1 2 3 4 10ms 40s 1m30s 1h5m30s20ms Interpolation \u2693\ufe0e Values in a Compose file can be set by variables, and interpolated at runtime. Compose files use a Bash-like syntax ${VARIABLE} Both $VARIABLE and ${VARIABLE} syntax are supported. Default values can be defined inline using typical shell syntax: latest ${VARIABLE:-default} evaluates to default if VARIABLE is unset or empty in the environment. ${VARIABLE-default} evaluates to default only if VARIABLE is unset in the environment. Similarly, the following syntax allows you to specify mandatory variables: ${VARIABLE:?err} exits with an error message containing err if VARIABLE is unset or empty in the environment. ${VARIABLE?err} exits with an error message containing err if VARIABLE is unset in the environment. Other extended shell-style features, such as ${VARIABLE/foo/bar} , are not supported by the Compose specification. You can use a $$ (double-dollar sign) when your configuration needs a literal dollar sign. This also prevents Compose from interpolating a value, so a $$ allows you to refer to environment variables that you don't want processed by Compose. 1 2 3 web: build: . command: \"$$VAR_NOT_INTERPOLATED_BY_COMPOSE\" If the Compose implementation can't resolve a substituted variable and no default value is defined, it MUST warn the user and substitute the variable with an empty string. As any values in a Compose file can be interpolated with variable substitution, including compact string notation for complex elements, interpolation MUST be applied before merge on a per-file-basis.","title":"Spec"},{"location":"dev/docker/compose/spec/#the-compose-specification","text":"Note This document has been reproduced here from its original source to provide a better reading experience.","title":"The Compose Specification"},{"location":"dev/docker/compose/spec/#status-of-this-document","text":"This document specifies the Compose file format used to define multi-containers applications. Distribution of this document is unlimited. The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 .","title":"Status of this document"},{"location":"dev/docker/compose/spec/#requirements-and-optional-attributes","text":"The Compose specification includes properties designed to target a local OCI container runtime, exposing Linux kernel specific configuration options, but also some Windows container specific properties, as well as cloud platform features related to resource placement on a cluster, replicated application distribution and scalability. We acknowledge that no Compose implementation is expected to support all attributes, and that support for some properties is Platform dependent and can only be confirmed at runtime. The definition of a versioned schema to control the supported properties in a Compose file, established by the docker-compose tool where the Compose file format was designed, doesn't offer any guarantee to the end-user attributes will be actually implemented. The specification defines the expected configuration syntax and behaviour, but - until noted - supporting any of those is OPTIONAL. A Compose implementation to parse a Compose file using unsupported attributes SHOULD warn user. We recommend implementors to support those running modes: default: warn user about unsupported attributes, but ignore them strict: warn user about unsupported attributes and reject the compose file loose: ignore unsupported attributes AND unknown attributes (that were not defined by the spec by the time implementation was created)","title":"Requirements and optional attributes"},{"location":"dev/docker/compose/spec/#the-compose-application-model","text":"The Compose specification allows one to define a platform-agnostic container based application. Such an application is designed as a set of containers which have to both run together with adequate shared resources and communication channels. Computing components of an application are defined as Services . A Service is an abstract concept implemented on platforms by running the same container image (and configuration) one or more times. Services communicate with each other through Networks . In this specification, a Network is a platform capability abstraction to establish an IP route between containers within services connected together. Low-level, platform-specific networking options are grouped into the Network definition and MAY be partially implemented on some platforms. Services store and share persistent data into Volumes . The specification describes such a persistent data as a high-level filesystem mount with global options. Actual platform-specific implementation details are grouped into the Volumes definition and MAY be partially implemented on some platforms. Some services require configuration data that is dependent on the runtime or platform. For this, the specification defines a dedicated concept: Configs . From a Service container point of view, Configs are comparable to Volumes, in that they are files mounted into the container. But the actual definition involves distinct platform resources and services, which are abstracted by this type. A Secret is a specific flavour of configuration data for sensitive data that SHOULD NOT be exposed without security considerations. Secrets are made available to services as files mounted into their containers, but the platform-specific resources to provide sensitive data are specific enough to deserve a distinct concept and definition within the Compose specification. Distinction within Volumes, Configs and Secret allows implementations to offer a comparable abstraction at service level, but cover the specific configuration of adequate platform resources for well identified data usages. A Project is an individual deployment of an application specification on a platform. A project's name is used to group resources together and isolate them from other applications or other installation of the same Compose specified application with distinct parameters. A Compose implementation creating resources on a platform MUST prefix resource names by project and set the label com.docker.compose.project .","title":"The Compose application model"},{"location":"dev/docker/compose/spec/#illustrative-example","text":"The following example illustrates Compose specification concepts with a concrete example application. The example is non-normative. Consider an application split into a frontend web application and a backend service. The frontend is configured at runtime with an HTTP configuration file managed by infrastructure, providing an external domain name, and an HTTPS server certificate injected by the platform's secured secret store. The backend stores data in a persistent volume. Both services communicate with each other on an isolated back-tier network, while frontend is also connected to a front-tier network and exposes port 443 for external usage. 1 2 3 4 5 6 7 8 9 10 11 12 13 (External user) --> 443 [frontend network] | +--------------------+ | frontend service |...ro...<HTTP configuration> | \"webapp\" |...ro...<server certificate> #secured +--------------------+ | [backend network] | +--------------------+ | backend service | r+w ___________________ | \"database\" |=======( persistent volume ) +--------------------+ \\_________________/ The example application is composed of the following parts: - 2 services, backed by Docker images: webapp and database - 1 secret (HTTPS certificate), injected into the frontend - 1 configuration (HTTP), injected into the frontend - 1 persistent volume, attached to the backend - 2 networks 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 services: frontend: image: awesome/webapp ports: - \"443:8043\" networks: - front-tier - back-tier configs: - httpd-config secrets: - server-certificate backend: image: awesome/database volumes: - db-data:/etc/data networks: - back-tier volumes: db-data: driver: flocker driver_opts: size: \"10GiB\" configs: httpd-config: external: true secrets: server-certificate: external: true networks: # The presence of these objects is sufficient to define them front-tier: {} back-tier: {} This example illustrates the distinction between volumes, configs and secrets. While all of them are all exposed to service containers as mounted files or directories, only a volume can be configured for read+write access. Secrets and configs are read-only. The volume configuration allows you to select a volume driver and pass driver options to tweak volume management according to the actual infrastructure. Configs and Secrets rely on platform services, and are declared external as they are not managed as part of the application lifecycle: the Compose implementation will use a platform-specific lookup mechanism to retrieve runtime values.","title":"Illustrative example"},{"location":"dev/docker/compose/spec/#compose-file","text":"The Compose file is a YAML file defining version (DEPRECATED), services (REQUIRED), networks , volumes , configs and secrets . The default path for a Compose file is compose.yaml (preferred) or compose.yml in working directory. Compose implementations SHOULD also support docker-compose.yaml and docker-compose.yml for backward compatibility. If both files exist, Compose implementations MUST prefer canonical compose.yaml one. Multiple Compose files can be combined together to define the application model. The combination of YAML files MUST be implemented by appending/overriding YAML elements based on Compose file order set by the user. Simple attributes and maps get overridden by the highest order Compose file, lists get merged by appending. Relative paths MUST be resolved based on the first Compose file's parent folder, whenever complimentary files being merged are hosted in other folders. As some Compose file elements can both be expressed as single strings or complex objects, merges MUST apply to the expanded form.","title":"Compose file"},{"location":"dev/docker/compose/spec/#profiles","text":"Profiles allow to adjust the Compose application model for various usages and environments. A Compose implementation SHOULD allow the user to define a set of active profiles. The exact mechanism is implementation specific and MAY include command line flags, environment variables, etc. The Services top-level element supports a profiles attribute to define a list of named profiles. Services without a profiles attribute set MUST always be enabled. A service MUST be ignored by the Compose implementation when none of the listed profiles match the active ones, unless the service is explicitly targeted by a command. In that case its profiles MUST be added to the set of active profiles. All other top-level elements are not affected by profiles and are always active. References to other services (by links , extends or shared resource syntax service:xxx ) MUST not automatically enable a component that would otherwise have been ignored by active profiles. Instead the Compose implementation MUST return an error.","title":"Profiles"},{"location":"dev/docker/compose/spec/#illustrative-example_1","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 services : foo : image : foo bar : image : bar profiles : - test baz : image : baz depends_on : - bar profiles : - test zot : image : zot depends_on : - bar profiles : - debug Compose application model parsed with no profile enabled only contains the foo service. If profile test is enabled, model contains the services bar and baz which are enabled by the test profile and service foo which is always enabled. If profile debug is enabled, model contains both foo and zot services, but not bar and baz and as such the model is invalid regarding the depends_on constraint of zot . If profiles debug and test are enabled, model contains all services: foo , bar , baz and zot . If Compose implementation is executed with bar as explicit service to run, it and the test profile will be active even if test profile is not enabled by the user . If Compose implementation is executed with baz as explicit service to run, the service baz and the profile test will be active and bar will be pulled in by the depends_on constraint. If Compose implementation is executed with zot as explicit service to run, again the model will be invalid regarding the depends_on constraint of zot since zot and bar have no common profiles listed. If Compose implementation is executed with zot as explicit service to run and profile test enabled, profile debug is automatically enabled and service bar is pulled in as a dependency starting both services zot and bar .","title":"Illustrative example"},{"location":"dev/docker/compose/spec/#version","text":"Top-level version property is defined by the specification for backward compatibility but is only informative. A Compose implementation SHOULD NOT use this version to select an exact schema to validate the Compose file, but prefer the most recent schema at the time it has been designed. Compose implementations SHOULD validate they can fully parse the Compose file. If some fields are unknown, typically because the Compose file was written with fields defined by a newer version of the specification, Compose implementations SHOULD warn the user. Compose implementations MAY offer options to ignore unknown fields (as defined by \"loose\" mode).","title":"Version top-level element"},{"location":"dev/docker/compose/spec/#services","text":"A Service is an abstract definition of a computing resource within an application which can be scaled/replaced independently from other components. Services are backed by a set of containers, run by the platform according to replication requirements and placement constraints. Being backed by containers, Services are defined by a Docker image and set of runtime arguments. All containers within a service are identically created with these arguments. A Compose file MUST declare a services root element as a map whose keys are string representations of service names, and whose values are service definitions. A service definition contains the configuration that is applied to each container started for that service. Each service MAY also include a Build section, which defines how to create the Docker image for the service. Compose implementations MAY support building docker images using this service definition. If not implemented the Build section SHOULD be ignored and the Compose file MUST still be considered valid. Build support is an OPTIONAL aspect of the Compose specification, and is described in detail here Each Service defines runtime constraints and requirements to run its containers. The deploy section groups these constraints and allows the platform to adjust the deployment strategy to best match containers' needs with available resources. Deploy support is an OPTIONAL aspect of the Compose specification, and is described in detail here . If not implemented the Deploy section SHOULD be ignored and the Compose file MUST still be considered valid.","title":"Services top-level element"},{"location":"dev/docker/compose/spec/#deploy","text":"deploy specifies the configuration for the deployment and lifecycle of services, as defined here .","title":"deploy"},{"location":"dev/docker/compose/spec/#blkio_config","text":"blkio_config defines a set of configuration options to set block IO limits for this service. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 services: foo: image: busybox blkio_config: weight: 300 weight_device: - path: /dev/sda weight: 400 device_read_bps: - path: /dev/sdb rate: '12mb' device_read_iops: - path: /dev/sdb rate: 120 device_write_bps: - path: /dev/sdb rate: '1024k' device_write_iops: - path: /dev/sdb rate: 30","title":"blkio_config"},{"location":"dev/docker/compose/spec/#device_read_bps-device_write_bps","text":"Set a limit in bytes per second for read / write operations on a given device. Each item in the list MUST have two keys: path : defining the symbolic path to the affected device. rate : either as an integer value representing the number of bytes or as a string expressing a byte value.","title":"device_read_bps, device_write_bps"},{"location":"dev/docker/compose/spec/#device_read_iops-device_write_iops","text":"Set a limit in operations per second for read / write operations on a given device. Each item in the list MUST have two keys: path : defining the symbolic path to the affected device. rate : as an integer value representing the permitted number of operations per second.","title":"device_read_iops, device_write_iops"},{"location":"dev/docker/compose/spec/#weight","text":"Modify the proportion of bandwidth allocated to this service relative to other services. Takes an integer value between 10 and 1000, with 500 being the default.","title":"weight"},{"location":"dev/docker/compose/spec/#weight_device","text":"Fine-tune bandwidth allocation by device. Each item in the list must have two keys: path : defining the symbolic path to the affected device. weight : an integer value between 10 and 1000.","title":"weight_device"},{"location":"dev/docker/compose/spec/#cpu_count","text":"cpu_count defines the number of usable CPUs for service container.","title":"cpu_count"},{"location":"dev/docker/compose/spec/#cpu_percent","text":"cpu_percent defines the usable percentage of the available CPUs.","title":"cpu_percent"},{"location":"dev/docker/compose/spec/#cpu_shares","text":"cpu_shares defines (as integer value) service container relative CPU weight versus other containers.","title":"cpu_shares"},{"location":"dev/docker/compose/spec/#cpu_period","text":"cpu_period allow Compose implementations to configure CPU CFS (Completely Fair Scheduler) period when platform is based on Linux kernel.","title":"cpu_period"},{"location":"dev/docker/compose/spec/#cpu_quota","text":"cpu_quota allow Compose implementations to configure CPU CFS (Completely Fair Scheduler) quota when platform is based on Linux kernel.","title":"cpu_quota"},{"location":"dev/docker/compose/spec/#cpu_rt_runtime","text":"cpu_rt_runtime configures CPU allocation parameters for platform with support for realtime scheduler. Can be either an integer value using microseconds as unit or a duration . 1 2 cpu_rt_runtime: '400ms' cpu_rt_runtime: 95000`","title":"cpu_rt_runtime"},{"location":"dev/docker/compose/spec/#cpu_rt_period","text":"cpu_rt_period configures CPU allocation parameters for platform with support for realtime scheduler. Can be either an integer value using microseconds as unit or a duration . 1 2 cpu_rt_period: '1400us' cpu_rt_period: 11000`","title":"cpu_rt_period"},{"location":"dev/docker/compose/spec/#cpus","text":"DEPRECATED: use deploy.reservations.cpus cpus define the number of (potentially virtual) CPUs to allocate to service containers. This is a fractional number. 0.000 means no limit.","title":"cpus"},{"location":"dev/docker/compose/spec/#cpuset","text":"cpuset defines the explicit CPUs in which to allow execution. Can be a range 0-3 or a list 0,1","title":"cpuset"},{"location":"dev/docker/compose/spec/#build","text":"build specifies the build configuration for creating container image from source, as defined here .","title":"build"},{"location":"dev/docker/compose/spec/#cap_add","text":"cap_add specifies additional container capabilities as strings. 1 2 cap_add: - ALL","title":"cap_add"},{"location":"dev/docker/compose/spec/#cap_drop","text":"cap_drop specifies container capabilities to drop as strings. 1 2 3 cap_drop: - NET_ADMIN - SYS_ADMIN","title":"cap_drop"},{"location":"dev/docker/compose/spec/#cgroup_parent","text":"cgroup_parent specifies an OPTIONAL parent cgroup for the container. 1 cgroup_parent: m-executor-abcd","title":"cgroup_parent"},{"location":"dev/docker/compose/spec/#command","text":"command overrides the the default command declared by the container image (i.e. by Dockerfile's CMD ). 1 command: bundle exec thin -p 3000 The command can also be a list, in a manner similar to Dockerfile : 1 command: [ \"bundle\", \"exec\", \"thin\", \"-p\", \"3000\" ]","title":"command"},{"location":"dev/docker/compose/spec/#configs","text":"configs grant access to configs on a per-service basis using the per-service configs configuration. Two different syntax variants are supported. Compose implementations MUST report an error if config doesn't exist on platform or isn't defined in the configs section of this Compose file. There are two syntaxes defined for configs. To remain compliant to this specification, an implementation MUST support both syntaxes. Implementations MUST allow use of both short and long syntaxes within the same document.","title":"configs"},{"location":"dev/docker/compose/spec/#short-syntax","text":"The short syntax variant only specifies the config name. This grants the container access to the config and mounts it at /<config_name> within the container. The source name and destination mount point are both set to the config name. The following example uses the short syntax to grant the redis service access to the my_config and my_other_config configs. The value of my_config is set to the contents of the file ./my_config.txt , and my_other_config is defined as an external resource, which means that it has already been defined in the platform. If the external config does not exist, the deployment MUST fail. 1 2 3 4 5 6 7 8 9 10 services: redis: image: redis:latest configs: - my_config configs: my_config: file: ./my_config.txt my_other_config: external: true","title":"Short syntax"},{"location":"dev/docker/compose/spec/#long-syntax","text":"The long syntax provides more granularity in how the config is created within the service's task containers. source : The name of the config as it exists in the platform. target : The path and name of the file to be mounted in the service's task containers. Defaults to /<source> if not specified. uid and gid : The numeric UID or GID that owns the mounted config file within the service's task containers. Default value when not specified is USER running container. mode : The permissions for the file that is mounted within the service's task containers, in octal notation. Default value is world-readable ( 0444 ). Writable bit MUST be ignored. The executable bit can be set. The following example sets the name of my_config to redis_config within the container, sets the mode to 0440 (group-readable) and sets the user and group to 103 . The redis service does not have access to the my_other_config config. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 services: redis: image: redis:latest configs: - source: my_config target: /redis_config uid: \"103\" gid: \"103\" mode: 0440 configs: my_config: external: true my_other_config: external: true You can grant a service access to multiple configs, and you can mix long and short syntax.","title":"Long syntax"},{"location":"dev/docker/compose/spec/#container_name","text":"container_name is a string that specifies a custom container name, rather than a generated default name. 1 container_name: my-web-container Compose implementation MUST NOT scale a service beyond one container if the Compose file specifies a container_name . Attempting to do so MUST result in an error. If present, container_name SHOULD follow the regex format of [a-zA-Z0-9][a-zA-Z0-9_.-]+","title":"container_name"},{"location":"dev/docker/compose/spec/#credential_spec","text":"credential_spec configures the credential spec for a managed service account. Compose implementations that support services using Windows containers MUST support file: and registry: protocols for credential_spec. Compose implementations MAY also support additional protocols for custom use-cases. The credential_spec must be in the format file://<filename> or registry://<value-name> . 1 2 credential_spec: file: my-credential-spec.json When using registry: , the credential spec is read from the Windows registry on the daemon's host. A registry value with the given name must be located in: 1 HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Virtualization\\Containers\\CredentialSpecs The following example loads the credential spec from a value named my-credential-spec in the registry: 1 2 credential_spec: registry: my-credential-spec","title":"credential_spec"},{"location":"dev/docker/compose/spec/#example-gmsa-configuration","text":"When configuring a gMSA credential spec for a service, you only need to specify a credential spec with config , as shown in the following example: 1 2 3 4 5 6 7 8 9 services: myservice: image: myimage:latest credential_spec: config: my_credential_spec configs: my_credentials_spec: file: ./my-credential-spec.json|","title":"Example gMSA configuration"},{"location":"dev/docker/compose/spec/#depends_on","text":"depends_on expresses startup and shutdown dependencies between services.","title":"depends_on"},{"location":"dev/docker/compose/spec/#short-syntax_1","text":"The short syntax variant only specifies service names of the dependencies. Service dependencies cause the following behaviors: Compose implementations MUST create services in dependency order. In the following example, db and redis are created before web . Compose implementations MUST remove services in dependency order. In the following example, web is removed before db and redis . Simple example: 1 2 3 4 5 6 7 8 9 10 services: web: build: . depends_on: - db - redis redis: image: redis db: image: postgres Compose implementations MUST guarantee dependency services have been started before starting a dependent service. Compose implementations MAY wait for dependency services to be \"ready\" before starting a dependent service.","title":"Short syntax"},{"location":"dev/docker/compose/spec/#long-syntax_1","text":"The long form syntax enables the configuration of additional fields that can't be expressed in the short form. condition : condition under which dependency is considered satisfied service_started : is an equivalent of the short syntax described above service_healthy : specifies that a dependency is expected to be \"healthy\" (as indicated by healthcheck ) before starting a dependent service. Service dependencies cause the following behaviors: Compose implementations MUST create services in dependency order. In the following example, db and redis are created before web . Compose implementations MUST wait for healthchecks to pass on dependencies marked with service_healthy . In the following example, db is expected to be \"healthy\" before web is created. Compose implementations MUST remove services in dependency order. In the following example, web is removed before db and redis . Simple example: 1 2 3 4 5 6 7 8 9 10 11 12 services: web: build: . depends_on: db: condition: service_healthy redis: condition: service_started redis: image: redis db: image: postgres Compose implementations MUST guarantee dependency services have been started before starting a dependent service. Compose implementations MUST guarantee dependency services marked with service_healthy are \"healthy\" before starting a dependent service.","title":"Long syntax"},{"location":"dev/docker/compose/spec/#device_cgroup_rules","text":"device_cgroup_rules defines a list of device cgroup rules for this container. The format is the same format the Linux kernel specifies in the Control Groups Device Whitelist Controller . 1 2 3 device_cgroup_rules: - 'c 1:3 mr' - 'a 7:* rmw'","title":"device_cgroup_rules"},{"location":"dev/docker/compose/spec/#devices","text":"devices defines a list of device mappings for created containers. 1 2 devices: - \"/dev/ttyUSB0:/dev/ttyUSB0\"","title":"devices"},{"location":"dev/docker/compose/spec/#dns","text":"dns defines custom DNS servers to set on the container network interface configuration. Can be a single value or a list. 1 dns: 8.8.8.8 1 2 3 dns: - 8.8.8.8 - 9.9.9.9","title":"dns"},{"location":"dev/docker/compose/spec/#dns_opt","text":"dns_opt list custom DNS options to be passed to the container\u2019s DNS resolver ( /etc/resolv.conf file on Linux). 1 2 3 dns_opt: - use-vc - no-tld-query","title":"dns_opt"},{"location":"dev/docker/compose/spec/#dns_search","text":"dns defines custom DNS search domains to set on container network interface configuration. Can be a single value or a list. 1 dns_search: example.com 1 2 3 dns_search: - dc1.example.com - dc2.example.com","title":"dns_search"},{"location":"dev/docker/compose/spec/#domainname","text":"domainname declares a custom domain name to use for the service container. MUST be a valid RFC 1123 hostname.","title":"domainname"},{"location":"dev/docker/compose/spec/#entrypoint","text":"entrypoint overrides the default entrypoint for the Docker image (i.e. ENTRYPOINT set by Dockerfile). Compose implementations MUST clear out any default command on the Docker image - both ENTRYPOINT and CMD instruction in the Dockerfile - when entrypoint is configured by a Compose file. If command is also set, it is used as parameter to entrypoint as a replacement for Docker image's CMD 1 entrypoint: /code/entrypoint.sh The entrypoint can also be a list, in a manner similar to Dockerfile : 1 2 3 4 5 6 7 entrypoint: - php - -d - zend_extension=/usr/local/lib/php/extensions/no-debug-non-zts-20100525/xdebug.so - -d - memory_limit=-1 - vendor/bin/phpunit","title":"entrypoint"},{"location":"dev/docker/compose/spec/#env_file","text":"env_file adds environment variables to the container based on file content. 1 env_file: .env env_file can also be a list. The files in the list MUST be processed from the top down. For the same variable specified in two env files, the value from the last file in the list MUST stand. 1 2 3 env_file: - ./a.env - ./b.env Relative path MUST be resolved from the Compose file's parent folder. As absolute paths prevent the Compose file from being portable, Compose implementations SHOULD warn users when such a path is used to set env_file . Environment variables declared in the environment section MUST override these values \u2013 this holds true even if those values are empty or undefined.","title":"env_file"},{"location":"dev/docker/compose/spec/#env_file-format","text":"Each line in an env file MUST be in VAR[=[VAL]] format. Lines beginning with # MUST be ignored. Blank lines MUST also be ignored. The value of VAL is used as a raw string and not modified at all. If the value is surrounded by quotes (as is often the case for shell variables), the quotes MUST be included in the value passed to containers created by the Compose implementation. VAL MAY be omitted, in such cases the variable value is empty string. =VAL MAY be omitted, in such cases the variable is unset . 1 2 3 # Set Rails/Rack environment RACK_ENV = development VAR = \"quoted\"","title":"Env_file format"},{"location":"dev/docker/compose/spec/#environment","text":"environment defines environment variables set in the container. environment can use either an array or a map. Any boolean values; true, false, yes, no, MUST be enclosed in quotes to ensure they are not converted to True or False by the YAML parser. Environment variables MAY be declared by a single key (no value to equals sign). In such a case Compose implementations SHOULD rely on some user interaction to resolve the value. If they do not, the variable is unset and will be removed from the service container environment. Map syntax: 1 2 3 4 environment: RACK_ENV: development SHOW: \"true\" USER_INPUT: Array syntax: 1 2 3 4 environment: - RACK_ENV=development - SHOW=true - USER_INPUT When both env_file and environment are set for a service, values set by environment have precedence.","title":"environment"},{"location":"dev/docker/compose/spec/#expose","text":"expose defines the ports that Compose implementations MUST expose from container. These ports MUST be accessible to linked services and SHOULD NOT be published to the host machine. Only the internal container ports can be specified. 1 2 3 expose: - \"3000\" - \"8000\"","title":"expose"},{"location":"dev/docker/compose/spec/#extends","text":"Extend another service, in the current file or another, optionally overriding configuration. You can use extends on any service together with other configuration keys. The extends value MUST be a mapping defined with a required service and an optional file key. 1 2 3 extends : file : common.yml service : webapp If supported Compose implementations MUST process extends in the following way: service defines the name of the service being referenced as a base, for example web or database . file is the location of a Compose configuration file defining that service.","title":"extends"},{"location":"dev/docker/compose/spec/#restrictions","text":"The following restrictions apply to the service being referenced: Services that have dependencies on other services cannot be used as a base. Therefore, any key that introduces a dependency on another service is incompatible with extends . The non-exhaustive list of such keys is: links , volumes_from , container mode (in ipc , pid , network_mode and net ), service mode (in ipc , pid and network_mode ), depends_on . Services cannot have circular references with extends Compose implementations MUST return an error in all of these cases.","title":"Restrictions"},{"location":"dev/docker/compose/spec/#finding-referenced-service","text":"file value can be: Not present. This indicates that another service within the same Compose file is being referenced. File path, which can be either: Relative path. This path is considered as relative to the location of the main Compose file. Absolute path. Service denoted by service MUST be present in the identified referenced Compose file. Compose implementations MUST return an error if: Service denoted by service was not found Compose file denoted by file was not found","title":"Finding referenced service"},{"location":"dev/docker/compose/spec/#merging-service-definitions","text":"Two service definitions ( main one in the current Compose file and referenced one specified by extends ) MUST be merged in the following way: Mappings: keys in mappings of main service definition override keys in mappings of referenced service definition. Keys that aren't overridden are included as is. Sequences: items are combined together into an new sequence. Order of elements is preserved with the referenced items coming first and main items after. Scalars: keys in main service definition take precedence over keys in the referenced one.","title":"Merging service definitions"},{"location":"dev/docker/compose/spec/#mappings","text":"The following keys should be treated as mappings: build.args , build.labels , build.extra_hosts , deploy.labels , deploy.update_config , deploy.rollback_config , deploy.restart_policy , deploy.resources.limits , environment , healthcheck , labels , logging.options , sysctls , storage_opt , extra_hosts , ulimits . One exception that applies to healthcheck is that main mapping cannot specify disable: true unless referenced mapping also specifies disable: true . Compose implementations MUST return an error in this case. For example, the input below: 1 2 3 4 5 6 7 8 9 10 11 services : common : image : busybox environment : TZ : utc PORT : 80 cli : extends : service : common environment : PORT : 8080 Produces the following configuration for the cli service. The same output is produced if array syntax is used. 1 2 3 4 environment : PORT : 8080 TZ : utc image : busybox Items under blkio_config.device_read_bps , blkio_config.device_read_iops , blkio_config.device_write_bps , blkio_config.device_write_iops , devices and volumes are also treated as mappings where key is the target path inside the container. For example, the input below: 1 2 3 4 5 6 7 8 9 10 services : common : image : busybox volumes : - common-volume:/var/lib/backup/data:rw cli : extends : service : common volumes : - cli-volume:/var/lib/backup/data:ro Produces the following configuration for the cli service. Note that mounted path now points to the new volume name and ro flag was applied. 1 2 3 image : busybox volumes : - cli-volume:/var/lib/backup/data:ro If referenced service definition contains extends mapping, the items under it are simply copied into the new merged definition. Merging process is then kicked off again until no extends keys are remaining. For example, the input below: 1 2 3 4 5 6 7 8 9 10 11 services : base : image : busybox user : root common : image : busybox extends : service : base cli : extends : service : common Produces the following configuration for the cli service. Here, cli services gets user key from common service, which in turn gets this key from base service. 1 2 image : busybox user : root","title":"Mappings"},{"location":"dev/docker/compose/spec/#sequences","text":"The following keys should be treated as sequences: cap_add , cap_drop , configs , deploy.placement.constraints , deploy.placement.preferences , deploy.reservations.generic_resources , device_cgroup_rules , expose , external_links , ports , secrets , security_opt . Any duplicates resulting from the merge are removed so that the sequence only contains unique elements. For example, the input below: 1 2 3 4 5 6 7 8 9 10 services : common : image : busybox security_opt : - label:role:ROLE cli : extends : service : common security_opt : - label:user:USER Produces the following configuration for the cli service. 1 2 3 4 image : busybox security_opt : - label:role:ROLE - label:user:USER In case list syntax is used, the following keys should also be treated as sequences: dns , dns_search , env_file , tmpfs . Unlike sequence fields mentioned above, duplicates resulting from the merge are not removed.","title":"Sequences"},{"location":"dev/docker/compose/spec/#scalars","text":"Any other allowed keys in the service definition should be treated as scalars.","title":"Scalars"},{"location":"dev/docker/compose/spec/#external_links","text":"external_links link service containers to services managed outside this Compose application. external_links define the name of an existing service to retrieve using the platform lookup mechanism. An alias of the form SERVICE:ALIAS can be specified. 1 2 3 4 external_links: - redis - database:mysql - database:postgresql","title":"external_links"},{"location":"dev/docker/compose/spec/#extra_hosts","text":"extra_hosts adds hostname mappings to the container network interface configuration ( /etc/hosts for Linux). Values MUST set hostname and IP address for additional hosts in the form of HOSTNAME:IP . 1 2 3 extra_hosts: - \"somehost:162.242.195.82\" - \"otherhost:50.31.209.229\" Compose implementations MUST create matching entry with the IP address and hostname in the container's network configuration, which means for Linux /etc/hosts will get extra lines: 1 2 162.242.195.82 somehost 50.31.209.229 otherhost","title":"extra_hosts"},{"location":"dev/docker/compose/spec/#group_add","text":"group_add specifies additional groups (by name or number) which the user inside the container MUST be a member of. An example of where this is useful is when multiple containers (running as different users) need to all read or write the same file on a shared volume. That file can be owned by a group shared by all the containers, and specified in group_add . 1 2 3 4 5 services: myservice: image: alpine group_add: - mail Running id inside the created container MUST show that the user belongs to the mail group, which would not have been the case if group_add were not declared.","title":"group_add"},{"location":"dev/docker/compose/spec/#healthcheck","text":"healthcheck declares a check that's run to determine whether or not containers for this service are \"healthy\". This overrides HEALTHCHECK Dockerfile instruction set by the service's Docker image. 1 2 3 4 5 6 healthcheck: test: [\"CMD\", \"curl\", \"-f\", \"http://localhost\"] interval: 1m30s timeout: 10s retries: 3 start_period: 40s interval , timeout and start_period are specified as durations . test defines the command the Compose implementation will run to check container health. It can be either a string or a list. If it's a list, the first item must be either NONE , CMD or CMD-SHELL . If it's a string, it's equivalent to specifying CMD-SHELL followed by that string. 1 2 # Hit the local web app test: [\"CMD\", \"curl\", \"-f\", \"http://localhost\"] Using CMD-SHELL will run the command configured as a string using the container's default shell ( /bin/sh for Linux). Both forms below are equivalent: 1 test: [\"CMD-SHELL\", \"curl -f http://localhost || exit 1\"] 1 test: curl -f https://localhost || exit 1 NONE disable the healthcheck, and is mostly useful to disable Healthcheck set by image. Alternatively the healthcheck set by the image can be disabled by setting disable: true : 1 2 healthcheck: disable: true","title":"healthcheck"},{"location":"dev/docker/compose/spec/#hostname","text":"hostname declares a custom host name to use for the service container. MUST be a valid RFC 1123 hostname.","title":"hostname"},{"location":"dev/docker/compose/spec/#image","text":"image specifies the image to start the container from. Image MUST follow the Open Container Specification addressable image format , as [<registry>/][<project>/]<image>[:<tag>|@<digest>] . 1 2 3 4 5 6 image: redis image: redis:5 image: redis@sha356:0ed5d5928d4737458944eb604cc8509e245c3e19d02ad83935398bc4b991aac7 image: library/redis image: docker.io/library/redis image: my_private.registry:5000/redis If the image does not exist on the platform, Compose implementations MUST attempt to pull it based on the pull_policy . Compose implementations with build support MAY offer alternative options for the end user to control precedence of pull over building the image from source, however pulling the image MUST be the default behavior. image MAY be omitted from a Compose file as long as a build section is declared. Compose implementations without build support MUST fail when image is missing from the Compose file.","title":"image"},{"location":"dev/docker/compose/spec/#init","text":"init run an init process (PID 1) inside the container that forwards signals and reaps processes. Set this option to true to enable this feature for the service. 1 2 3 4 services: web: image: alpine:latest init: true The init binary that is used is platform specific.","title":"init"},{"location":"dev/docker/compose/spec/#ipc","text":"ipc configures the IPC isolation mode set by service container. Available values are platform specific, but Compose specification defines specific values which MUST be implemented as described if supported: shareable which gives the container own private IPC namespace, with a possibility to share it with other containers. service:{name} which makes the container join another ( shareable ) container's IPC namespace. 1 2 ipc: \"shareable\" ipc: \"service:[service name]\"","title":"ipc"},{"location":"dev/docker/compose/spec/#isolation","text":"isolation specifies a container\u2019s isolation technology. Supported values are platform-specific.","title":"isolation"},{"location":"dev/docker/compose/spec/#labels","text":"labels add metadata to containers. You can use either an array or a map. It's recommended that you use reverse-DNS notation to prevent your labels from conflicting with those used by other software. 1 2 3 4 labels: com.example.description: \"Accounting webapp\" com.example.department: \"Finance\" com.example.label-with-empty-value: \"\" 1 2 3 4 labels: - \"com.example.description=Accounting webapp\" - \"com.example.department=Finance\" - \"com.example.label-with-empty-value\" Compose implementations MUST create containers with canonical labels: com.docker.compose.project set on all resources created by Compose implementation to the user project name com.docker.compose.service set on service containers with service name as defined in the Compose file The com.docker.compose label prefix is reserved. Specifying labels with this previx in the Compose file MUST result in a runtime error.","title":"labels"},{"location":"dev/docker/compose/spec/#links","text":"links defines a network link to containers in another service. Either specify both the service name and a link alias ( SERVICE:ALIAS ), or just the service name. 1 2 3 4 5 web: links: - db - db:database - redis Containers for the linked service MUST be reachable at a hostname identical to the alias, or the service name if no alias was specified. Links are not required to enable services to communicate - when no specific network configuration is set, any service MUST be able to reach any other service at that service\u2019s name on the default network. If services do declare networks they are attached to, links SHOULD NOT override the network configuration and services not attached to a shared network SHOULD NOT be able to communicate. Compose implementations MAY NOT warn the user about this configuration mismatch. Links also express implicit dependency between services in the same way as depends_on , so they determine the order of service startup.","title":"links"},{"location":"dev/docker/compose/spec/#logging","text":"logging defines the logging configuration for the service. 1 2 3 4 logging: driver: syslog options: syslog-address: \"tcp://192.168.0.42:123\" The driver name specifies a logging driver for the service's containers. The default and available values are platform specific. Driver specific options can be set with options as key-value pairs.","title":"logging"},{"location":"dev/docker/compose/spec/#network_mode","text":"network_mode set service containers network mode. Available values are platform specific, but Compose specification define specific values which MUST be implemented as described if supported: none which disable all container networking host which gives the container raw access to host's network interface service:{name} which gives the containers access to the specified service only 1 2 3 network_mode: \"host\" network_mode: \"none\" network_mode: \"service:[service name]\"","title":"network_mode"},{"location":"dev/docker/compose/spec/#networks","text":"networks defines the networks that service containers are attached to, referencing entries under the top-level networks key . 1 2 3 4 5 services: some-service: networks: - some-network - other-network","title":"networks"},{"location":"dev/docker/compose/spec/#aliases","text":"aliases declares alternative hostnames for this service on the network. Other containers on the same network can use either the service name or this alias to connect to one of the service's containers. Since aliases are network-scoped, the same service can have different aliases on different networks. Note : A network-wide alias can be shared by multiple containers, and even by multiple services. If it is, then exactly which container the name resolves to is not guaranteed. The general format is shown here: 1 2 3 4 5 6 7 8 9 10 services: some-service: networks: some-network: aliases: - alias1 - alias3 other-network: aliases: - alias2 In the example below, service frontend will be able to reach the backend service at the hostname backend or database on the back-tier network, and service monitoring will be able to reach same backend service at db or mysql on the admin network. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 services: frontend: image: awesome/webapp networks: - front-tier - back-tier monitoring: image: awesome/monitoring networks: - admin backend: image: awesome/backend networks: back-tier: aliases: - database admin: aliases: - mysql networks: front-tier: back-tier: admin:","title":"aliases"},{"location":"dev/docker/compose/spec/#ipv4_address-ipv6_address","text":"Specify a static IP address for containers for this service when joining the network. The corresponding network configuration in the top-level networks section MUST have an ipam block with subnet configurations covering each static address. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 services: frontend: image: awesome/webapp networks: front-tier: ipv4_address: 172.16.238.10 ipv6_address: 2001:3984:3989::10 networks: front-tier: ipam: driver: default config: - subnet: \"172.16.238.0/24\" - subnet: \"2001:3984:3989::/64\"","title":"ipv4_address, ipv6_address"},{"location":"dev/docker/compose/spec/#link_local_ips","text":"link_local_ips specifies a list of link-local IPs. Link-local IPs are special IPs which belong to a well known subnet and are purely managed by the operator, usually dependent on the architecture where they are deployed. Implementation is Platform specific. Example: 1 2 3 4 5 6 7 8 9 10 11 12 services : app : image : busybox command : top networks : app_net : link_local_ips : - 57.123.22.11 - 57.123.22.13 networks : app_net : driver : bridge","title":"link_local_ips"},{"location":"dev/docker/compose/spec/#priority","text":"priority indicates in which order Compose implementation SHOULD connect the service\u2019s containers to its networks. If unspecified, the default value is 0. In the following example, the app service connects to app_net_1 first as it has the highest priority. It then connects to app_net_3, then app_net_2, which uses the default priority value of 0. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 services : app : image : busybox command : top networks : app_net_1 : priority : 1000 app_net_2 : app_net_3 : priority : 100 networks : app_net_1 : app_net_2 : app_net_3 :","title":"priority"},{"location":"dev/docker/compose/spec/#mac_address","text":"mac_address sets a MAC address for service container.","title":"mac_address"},{"location":"dev/docker/compose/spec/#mem_limit","text":"DEPRECATED: use deploy.limits.memory","title":"mem_limit"},{"location":"dev/docker/compose/spec/#mem_reservation","text":"DEPRECATED: use deploy.reservations.memory","title":"mem_reservation"},{"location":"dev/docker/compose/spec/#mem_swappiness","text":"mem_swappiness defines as a percentage (a value between 0 and 100) for the host kernel to swap out anonymous memory pages used by a container. a value of 0 turns off anonymous page swapping. a value of 100 sets all anonymous pages as swappable. Default value is platform specific.","title":"mem_swappiness"},{"location":"dev/docker/compose/spec/#memswap_limit","text":"memswap_limit defines the amount of memory container is allowed to swap to disk. This is a modifier attribute that only has meaning if memory is also set. Using swap allows the container to write excess memory requirements to disk when the container has exhausted all the memory that is available to it. There is a performance penalty for applications that swap memory to disk often. If memswap_limit is set to a positive integer, then both memory and memswap_limit MUST be set. memswap_limit represents the total amount of memory and swap that can be used, and memory controls the amount used by non-swap memory. So if memory =\"300m\" and memswap_limit =\"1g\", the container can use 300m of memory and 700m (1g - 300m) swap. If memswap_limit is set to 0, the setting MUST be ignored, and the value is treated as unset. If memswap_limit is set to the same value as memory , and memory is set to a positive integer, the container does not have access to swap. See Prevent a container from using swap. If memswap_limit is unset, and memory is set, the container can use as much swap as the memory setting, if the host container has swap memory configured. For instance, if memory =\"300m\" and memswap_limit is not set, the container can use 600m in total of memory and swap. If memswap_limit is explicitly set to -1, the container is allowed to use unlimited swap, up to the amount available on the host system.","title":"memswap_limit"},{"location":"dev/docker/compose/spec/#oom_kill_disable","text":"If oom_kill_disable is set Compose implementation MUST configure the platform so it won't kill the container in case of memory starvation.","title":"oom_kill_disable"},{"location":"dev/docker/compose/spec/#oom_score_adj","text":"oom_score_adj tunes the preference for containers to be killed by platform in case of memory starvation. Valu MUST be within [-1000,1000] range.","title":"oom_score_adj"},{"location":"dev/docker/compose/spec/#pid","text":"pid sets the PID mode for container created by the Compose implementation. Supported values are platform specific.","title":"pid"},{"location":"dev/docker/compose/spec/#pid_limit","text":"pid_limit tunes a container\u2019s PIDs limit. Set to -1 for unlimited PIDs. 1 pids_limit: 10","title":"pid_limit"},{"location":"dev/docker/compose/spec/#platform","text":"platform defines the target platform containers for this service will run on, using the os[/arch[/variant]] syntax. Compose implementation MUST use this attribute when declared to determine which version of the image will be pulled and/or on which platform the service\u2019s build will be performed. 1 2 3 platform: osx platform: windows/amd64 platform: linux/arm64/v8","title":"platform"},{"location":"dev/docker/compose/spec/#ports","text":"Exposes container ports. Port mapping MUST NOT be used with network_mode: host and doing so MUST result in a runtime error.","title":"ports"},{"location":"dev/docker/compose/spec/#short-syntax_2","text":"The short syntax is a comma-separated string to set host IP, host port and container port in the form: [HOST:]CONTAINER[/PROTOCOL] where: HOST is [IP:](port | range) CONTAINER is port | range PROTOCOL to restrict port to specified protocol. tcp and udp values are defined by the specification, Compose implementations MAY offer support for platform-specific protocol names. Host IP, if not set, MUST bind to all network interfaces. Port can be either a single value or a range. Host and container MUST use equivalent ranges. Either specify both ports ( HOST:CONTAINER ), or just the container port. In the latter case, the Compose implementation SHOULD automatically allocate and unassigned host port. HOST:CONTAINER SHOULD always be specified as a (quoted) string, to avoid conflicts with yaml base-60 float . Samples: 1 2 3 4 5 6 7 8 9 ports: - \"3000\" - \"3000-3005\" - \"8000:8000\" - \"9090-9091:8080-8081\" - \"49100:22\" - \"127.0.0.1:8001:8001\" - \"127.0.0.1:5000-5010:5000-5010\" - \"6060:6060/udp\" Note : Host IP mapping MAY not be supported on the platform, in such case Compose implementations SHOULD reject the Compose file and MUST inform the user they will ignore the specified host IP.","title":"Short syntax"},{"location":"dev/docker/compose/spec/#long-syntax_2","text":"The long form syntax allows the configuration of additional fields that can't be expressed in the short form. target : the container port published : the publicly exposed port protocol : the port protocol ( tcp or udp ), unspecified means any protocol mode : host for publishing a host port on each node, or ingress for a port to be load balanced. 1 2 3 4 5 ports: - target: 80 published: 8080 protocol: tcp mode: host","title":"Long syntax"},{"location":"dev/docker/compose/spec/#privileged","text":"privileged configures the service container to run with elevated privileges. Support and actual impacts are platform-specific.","title":"privileged"},{"location":"dev/docker/compose/spec/#profiles_1","text":"profiles defines a list of named profiles for the service to be enabled under. When not set, service is always enabled. If present, profiles SHOULD follow the regex format of [a-zA-Z0-9][a-zA-Z0-9_.-]+ .","title":"profiles"},{"location":"dev/docker/compose/spec/#pull_policy","text":"pull_policy defines the decisions Compose implementations will make when it starts to pull images. Possible values are: always : Compose implementations SHOULD always pull the image from the registry. never : Compose implementations SHOULD NOT pull the image from a registry and SHOULD rely on the platform cached image. If there is no cached image, a failure MUST be reported. if_not_present : Compose implementations SHOULD pull the image only if it's not available in the platform cache.This SHOULD be the default option for Compose implementations without build support. build : Compose implementations SHOULD build the image. Compose implementations SHOULD rebuild the image if already present. If pull_policy and build both presents, Compose implementations SHOULD build the image by default. Compose implementations MAY override this behavior in the toolchain.","title":"pull_policy"},{"location":"dev/docker/compose/spec/#read_only","text":"read_only configures service container to be created with a read-only filesystem.","title":"read_only"},{"location":"dev/docker/compose/spec/#restart","text":"restart defines the policy that the platform will apply on container termination. no : The default restart policy. Does not restart a container under any circumstances. always : The policy always restarts the container until its removal. on-failure : The policy restarts a container if the exit code indicates an error. unless-stopped : The policy restarts a container irrespective of the exit code but will stop restarting when the service is stopped or removed. 1 2 3 4 restart: \"no\" restart: always restart: on-failure restart: unless-stopped","title":"restart"},{"location":"dev/docker/compose/spec/#runtime","text":"DEPRECATED: this attribute is low-level platform implementation detail runtime specifies which runtime to use for the service\u2019s containers. 1 2 3 4 web: image: busybox:latest command: true runtime: runc","title":"runtime"},{"location":"dev/docker/compose/spec/#scale","text":"-DEPRECATED: use deploy/replicas _ scale specifies the default number of containers to deploy for this service.","title":"scale"},{"location":"dev/docker/compose/spec/#secrets","text":"secrets grants access to sensitive data defined by secrets on a per-service basis. Two different syntax variants are supported: the short syntax and the long syntax. Compose implementations MUST report an error if the secret doesn't exist on the platform or isn't defined in the secrets section of this Compose file.","title":"secrets"},{"location":"dev/docker/compose/spec/#short-syntax_3","text":"The short syntax variant only specifies the secret name. This grants the container access to the secret and mounts it as read-only to /run/secrets/<secret_name> within the container. The source name and destination mountpoint are both set to the secret name. The following example uses the short syntax to grant the frontend service access to the server-certificate secret. The value of server-certificate is set to the contents of the file ./server.cert . 1 2 3 4 5 6 7 8 services: frontend: image: awesome/webapp secrets: - server-certificate secrets: server-certificate: file: ./server.cert","title":"Short syntax"},{"location":"dev/docker/compose/spec/#long-syntax_3","text":"The long syntax provides more granularity in how the secret is created within the service's containers. source : The name of the secret as it exists on the platform. target : The name of the file to be mounted in /run/secrets/ in the service's task containers. Defaults to source if not specified. uid and gid : The numeric UID or GID that owns the file within /run/secrets/ in the service's task containers. Default value is USER running container. mode : The permissions for the file to be mounted in /run/secrets/ in the service's task containers, in octal notation. Default value is world-readable permissions (mode 0444 ). The writable bit MUST be ignored if set. The executable bit MAY be set. The following example sets the name of the server-certificate secret file to server.crt within the container, sets the mode to 0440 (group-readable) and sets the user and group to 103 . The value of server-certificate secret is provided by the platform through a lookup and the secret lifecycle not directly managed by the Compose implementation. 1 2 3 4 5 6 7 8 9 10 11 12 services: frontend: image: awesome/webapp secrets: - source: server-certificate target: server.cert uid: \"103\" gid: \"103\" mode: 0440 secrets: server-certificate: external: true Services MAY be granted access to multiple secrets. Long and short syntax for secrets MAY be used in the same Compose file. Defining a secret in the top-level secrets MUTS NOT imply granting any service access to it. Such grant must be explicit within service specification as secrets service element.","title":"Long syntax"},{"location":"dev/docker/compose/spec/#security_opt","text":"security_opt overrides the default labeling scheme for each container. 1 2 3 security_opt: - label:user:USER - label:role:ROLE","title":"security_opt"},{"location":"dev/docker/compose/spec/#shm_size","text":"shm_size configures the size of the shared memory ( /dev/shm partition on Linux) allowed by the service container. Specified as a byte value .","title":"shm_size"},{"location":"dev/docker/compose/spec/#stdin_open","text":"stdin_open configures service containers to run with an allocated stdin.","title":"stdin_open"},{"location":"dev/docker/compose/spec/#stop_grace_period","text":"stop_grace_period specifies how long the Compose implementation MUST wait when attempting to stop a container if it doesn't handle SIGTERM (or whichever stop signal has been specified with stop_signal ), before sending SIGKILL. Specified as a duration . 1 2 stop_grace_period: 1s stop_grace_period: 1m30s Default value is 10 seconds for the container to exit before sending SIGKILL.","title":"stop_grace_period"},{"location":"dev/docker/compose/spec/#stop_signal","text":"stop_signal defines the signal that the Compose implementation MUST use to stop the service containers. If unset containers are stopped by the Compose Implementation by sending SIGTERM . 1 stop_signal: SIGUSR1","title":"stop_signal"},{"location":"dev/docker/compose/spec/#sysctls","text":"sysctls defines kernel parameters to set in the container. sysctls can use either an array or a map. 1 2 3 sysctls: net.core.somaxconn: 1024 net.ipv4.tcp_syncookies: 0 1 2 3 sysctls: - net.core.somaxconn=1024 - net.ipv4.tcp_syncookies=0 You can only use sysctls that are namespaced in the kernel. Docker does not support changing sysctls inside a container that also modify the host system. For an overview of supported sysctls, refer to configure namespaced kernel parameters (sysctls) at runtime .","title":"sysctls"},{"location":"dev/docker/compose/spec/#tmpfs","text":"tmpfs mounts a temporary file system inside the container. Can be a single value or a list. 1 tmpfs: /run 1 2 3 tmpfs: - /run - /tmp","title":"tmpfs"},{"location":"dev/docker/compose/spec/#tty","text":"tty configure service container to run with a TTY.","title":"tty"},{"location":"dev/docker/compose/spec/#ulimits","text":"ulimits overrides the default ulimits for a container. Either specifies as a single limit as an integer or soft/hard limits as a mapping. 1 2 3 4 5 ulimits: nproc: 65535 nofile: soft: 20000 hard: 40000","title":"ulimits"},{"location":"dev/docker/compose/spec/#user","text":"user overrides the user used to run the container process. Default is that set by image (i.e. Dockerfile USER ), if not set, root .","title":"user"},{"location":"dev/docker/compose/spec/#userns_mode","text":"userns_mode sets the user namespace for the service. Supported values are platform specific and MAY depend on platform configuration 1 userns_mode: \"host\"","title":"userns_mode"},{"location":"dev/docker/compose/spec/#volumes","text":"volumes defines mount host paths or named volumes that MUST be accessible by service containers. If the mount is a host path and only used by a single service, it MAY be declared as part of the service definition instead of the top-level volumes key. To reuse a volume across multiple services, a named volume MUST be declared in the top-level volumes key . This example shows a named volume ( db-data ) being used by the backend service, and a bind mount defined for a single service 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 services: backend: image: awesome/backend volumes: - type: volume source: db-data target: /data volume: nocopy: true - type: bind source: /var/run/postgres/postgres.sock target: /var/run/postgres/postgres.sock volumes: db-data:","title":"volumes"},{"location":"dev/docker/compose/spec/#short-syntax_4","text":"The short syntax uses a single string with comma-separated values to specify a volume mount ( VOLUME:CONTAINER_PATH ), or an access mode ( VOLUME:CONTAINER:ACCESS_MODE ). VOLUME MAY be either a host path on the platform hosting containers (bind mount) or a volume name. ACCESS_MODE MAY be set as read-only by using ro or read and write by using rw (default). Note : Relative host paths MUST only be supported by Compose implementations that deploy to a local container runtime. This is because the relative path is resolved from the Compose file\u2019s parent directory which is only applicable in the local case. Compose Implementations deploying to a non-local platform MUST reject Compose files which use relative host paths with an error. To avoid ambiguities with named volumes, relative paths SHOULD always begin with . or .. .","title":"Short syntax"},{"location":"dev/docker/compose/spec/#long-syntax_4","text":"The long form syntax allows the configuration of additional fields that can't be expressed in the short form. type : the mount type volume , bind , tmpfs or npipe source : the source of the mount, a path on the host for a bind mount, or the name of a volume defined in the top-level volumes key . Not applicable for a tmpfs mount. target : the path in the container where the volume is mounted read_only : flag to set the volume as read-only bind : configure additional bind options propagation : the propagation mode used for the bind volume : configure additional volume options nocopy : flag to disable copying of data from a container when a volume is created tmpfs : configure additional tmpfs options size : the size for the tmpfs mount in bytes consistency : the consistency requirements of the mount. Available values are platform specific","title":"Long syntax"},{"location":"dev/docker/compose/spec/#volumes_from","text":"volumes_from mounts all of the volumes from another service or container, optionally specifying read-only access (ro) or read-write (rw). If no access level is specified, then read-write MUST be used. String value defines another service in the Compose application model to mount volumes from. The container: prefix, if supported, allows to mount volumes from a container that is not managed by the Compose implementation. 1 2 3 4 5 volumes_from : - service_name - service_name:ro - container:container_name - container:container_name:rw","title":"volumes_from"},{"location":"dev/docker/compose/spec/#working_dir","text":"working_dir overrides the container's working directory from that specified by image (i.e. Dockerfile WORKDIR ).","title":"working_dir"},{"location":"dev/docker/compose/spec/#networks-top-level-element","text":"Networks are the layer that allow services to communicate with each other. The networking model exposed to a service is limited to a simple IP connection with target services and external resources, while the Network definition allows fine-tuning the actual implementation provided by the platform. Networks can be created by specifying the network name under a top-level networks section. Services can connect to networks by specifying the network name under the service networks subsection In the following example, at runtime, networks front-tier and back-tier will be created and the frontend service connected to the front-tier network and the back-tier network. 1 2 3 4 5 6 7 8 9 10 services: frontend: image: awesome/webapp networks: - front-tier - back-tier networks: front-tier: back-tier:","title":"Networks top-level element"},{"location":"dev/docker/compose/spec/#driver","text":"driver specifies which driver should be used for this network. Compose implementations MUST return an error if the driver is not available on the platform. 1 driver: overlay Default and available values are platform specific. Compose specification MUST support the following specific drivers: none and host host use the host's networking stack none disable networking","title":"driver"},{"location":"dev/docker/compose/spec/#host-or-none","text":"The syntax for using built-in networks such as host and none is different, as such networks implicitly exists outside the scope of the Compose implementation. To use them one MUST define an external network with the name host or none and an alias that the Compose implementation can use ( hostnet or nonet in the following examples), then grant the service access to that network using its alias. 1 2 3 4 5 6 7 8 9 services: web: networks: hostnet: {} networks: hostnet: external: true name: host 1 2 3 4 5 6 7 8 9 10 services: web: ... networks: nonet: {} networks: nonet: external: true name: none","title":"host or none"},{"location":"dev/docker/compose/spec/#driver_opts","text":"driver_opts specifies a list of options as key-value pairs to pass to the driver for this network. These options are driver-dependent - consult the driver's documentation for more information. Optional. 1 2 3 driver_opts: foo: \"bar\" baz: 1","title":"driver_opts"},{"location":"dev/docker/compose/spec/#attachable","text":"If attachable is set to true , then standalone containers SHOULD be able attach to this network, in addition to services. If a standalone container attaches to the network, it can communicate with services and other standalone containers that are also attached to the network. 1 2 3 4 networks: mynet1: driver: overlay attachable: true","title":"attachable"},{"location":"dev/docker/compose/spec/#enable_ipv6","text":"enable_ipv6 enable IPv6 networking on this network.","title":"enable_ipv6"},{"location":"dev/docker/compose/spec/#ipam","text":"ipam specifies custom a IPAM configuration. This is an object with several properties, each of which is optional: driver : Custom IPAM driver, instead of the default. config : A list with zero or more configuration elements, each containing: subnet : Subnet in CIDR format that represents a network segment ip_range : Range of IPs from which to allocate container IPs gateway : IPv4 or IPv6 gateway for the master subnet aux_addresses : Auxiliary IPv4 or IPv6 addresses used by Network driver, as a mapping from hostname to IP options : Driver-specific options as a key-value mapping. A full example: 1 2 3 4 5 6 7 8 9 10 11 12 13 ipam: driver: default config: - subnet: 172.28.0.0/16 ip_range: 172.28.5.0/24 gateway: 172.28.5.254 aux_addresses: host1: 172.28.1.5 host2: 172.28.1.6 host3: 172.28.1.7 options: foo: bar baz: \"0\"","title":"ipam"},{"location":"dev/docker/compose/spec/#internal","text":"By default, Compose implementations MUST provides external connectivity to networks. internal when set to true allow to create an externally isolated network.","title":"internal"},{"location":"dev/docker/compose/spec/#labels_1","text":"Add metadata to containers using Labels. Can use either an array or a dictionary. Users SHOULD use reverse-DNS notation to prevent labels from conflicting with those used by other software. 1 2 3 4 labels: com.example.description: \"Financial transaction network\" com.example.department: \"Finance\" com.example.label-with-empty-value: \"\" 1 2 3 4 labels: - \"com.example.description=Financial transaction network\" - \"com.example.department=Finance\" - \"com.example.label-with-empty-value\" Compose implementations MUST set com.docker.compose.project and com.docker.compose.network labels.","title":"labels"},{"location":"dev/docker/compose/spec/#external","text":"If set to true , external specifies that this network\u2019s lifecycle is maintained outside of that of the application. Compose Implementations SHOULD NOT attempt to create these networks, and raises an error if one doesn't exist. In the example below, proxy is the gateway to the outside world. Instead of attempting to create a network, Compose implementations SHOULD interrogate the platform for an existing network simply called outside and connect the proxy service's containers to it. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 services: proxy: image: awesome/proxy networks: - outside - default app: image: awesome/app networks: - default networks: outside: external: true","title":"external"},{"location":"dev/docker/compose/spec/#name","text":"name sets a custom name for this network. The name field can be used to reference networks which contain special characters. The name is used as is and will not be scoped with the project name. 1 2 3 networks: network1: name: my-app-net It can also be used in conjunction with the external property to define the platform network that the Compose implementation should retrieve, typically by using a parameter so the Compose file doesn't need to hard-code runtime specific values: 1 2 3 4 networks: network1: external: true name: \"${NETWORK_ID}\"","title":"name"},{"location":"dev/docker/compose/spec/#volumes-top-level-element","text":"Volumes are persistent data stores implemented by the platform. The Compose specification offers a neutral abstraction for services to mount volumes, and configuration parameters to allocate them on infrastructure. The volumes section allows the configuration of named volumes that can be reused across multiple services. Here's an example of a two-service setup where a database's data directory is shared with another service as a volume so that it can be periodically backed up: 1 2 3 4 5 6 7 8 9 10 11 12 13 services: backend: image: awesome/database volumes: - db-data:/etc/data backup: image: backup-service volumes: - db-data:/var/lib/backup/data volumes: db-data: An entry under the top-level volumes key can be empty, in which case it uses the platform's default configuration for creating a volume. Optionally, you can configure it with the following keys:","title":"Volumes top-level element"},{"location":"dev/docker/compose/spec/#driver_1","text":"Specify which volume driver should be used for this volume. Default and available values are platform specific. If the driver is not available, the Compose implementation MUST return an error and stop application deployment. 1 driver: foobar","title":"driver"},{"location":"dev/docker/compose/spec/#driver_opts_1","text":"driver_opts specifies a list of options as key-value pairs to pass to the driver for this volume. Those options are driver-dependent. 1 2 3 4 5 6 volumes: example: driver_opts: type: \"nfs\" o: \"addr=10.40.0.199,nolock,soft,rw\" device: \":/docker/example\"","title":"driver_opts"},{"location":"dev/docker/compose/spec/#external_1","text":"If set to true , external specifies that this volume already exist on the platform and its lifecycle is managed outside of that of the application. Compose implementations MUST NOT attempt to create these volumes, and MUST return an error they do not exist. In the example below, instead of attempting to create a volume called {project_name}_data , Compose looks for an existing volume simply called data and mount it into the db service's containers. 1 2 3 4 5 6 7 8 9 services: backend: image: awesome/database volumes: - db-data:/etc/data volumes: db-data: external: true","title":"external"},{"location":"dev/docker/compose/spec/#labels_2","text":"labels are used to add metadata to volumes. You can use either an array or a dictionary. It's recommended that you use reverse-DNS notation to prevent your labels from conflicting with those used by other software. 1 2 3 4 labels: com.example.description: \"Database volume\" com.example.department: \"IT/Ops\" com.example.label-with-empty-value: \"\" 1 2 3 4 labels: - \"com.example.description=Database volume\" - \"com.example.department=IT/Ops\" - \"com.example.label-with-empty-value\" Compose implementation MUST set com.docker.compose.project and com.docker.compose.volmume labels.","title":"labels"},{"location":"dev/docker/compose/spec/#name_1","text":"name set a custom name for this volume. The name field can be used to reference volumes that contain special characters. The name is used as is and will not be scoped with the stack name. 1 2 3 volumes: data: name: \"my-app-data\" It can also be used in conjunction with the external property. Doing so the name of the volume used to lookup for actual volume on platform is set separately from the name used to refer to it within the Compose file: 1 2 3 4 volumes: db-data: external: name: actual-name-of-volume This make it possible to make this lookup name a parameter of a Compose file, so that the model ID for volume is hard-coded but the actual volume ID on platform is set at runtime during deployment: 1 2 3 4 volumes: db-data: external: name: ${DATABASE_VOLUME}","title":"name"},{"location":"dev/docker/compose/spec/#configs-top-level-element","text":"Configs allow services to adapt their behaviour without the need to rebuild a Docker image. Configs are comparable to Volumes from a service point of view as they are mounted into service's containers filesystem. The actual implementation detail to get configuration provided by the platform can be set from the Configuration definition. When granted accessto a config, the config content is mounted as a file in the container. The location of the mount point within the container defaults to /<config-name> in Linux containers and C:\\<config-name> in Windows containers. By default, the config MUST be owned by the user running the container command but can be overriden by service configuration. By default, the config MUST have world-readable permissions (mode 0444), unless service is configured to override this. Services can only access configs when explicitly granted by a configs subsection. The top-level configs declaration defines or references configuration data that can be granted to the services in this application. The source of the config is either file or external . file : The config is created with the contents of the file at the specified path. external : If set to true, specifies that this config has already been created. Compose implementation does not attempt to create it, and if it does not exist, an error occurs. name : The name of config object on Platform to lookup. This field can be used to reference configs that contain special characters. The name is used as is and will not be scoped with the project name. In this example, http_config is created (as <project_name>_http_config) when the application is deployed, and my_second_config MUST already exists on Platform and value will be obtained by lookup. In this example, server-http_config is created as <project_name>_http_config when the application is deployed, by registering content of the httpd.conf as configuration data. 1 2 3 configs: http_config: file: ./httpd.conf Alternatively, http_config can be declared as external, doing so Compose implementation will lookup server-certificate to expose configuration data to relevant services. 1 2 3 configs: http_config: external: true External configs lookup can also use a distinct key by specifying a name . The following example modifies the previous one to lookup for config using a parameter HTTP_CONFIG_KEY . Doing so the actual lookup key will be set at deployment time by interpolation of variables, but exposed to containers as hard-coded ID http_config . 1 2 3 4 configs: http_config: external: true name: \"${HTTP_CONFIG_KEY}\" Compose file need to explicitly grant access to the configs to relevant services in the application.","title":"Configs top-level element"},{"location":"dev/docker/compose/spec/#secrets-top-level-element","text":"Secrets are a flavour of Configs focussing on sensitive data, with specific constraint for this usage. As the platform implementation may significally differ from Configs, dedicated Secrets section allows to configure the related resources. The top-level secrets declaration defines or references sensitive data that can be granted to the services in this application. The source of the secret is either file or external . file : The secret is created with the contents of the file at the specified path. external : If set to true, specifies that this secret has already been created. Compose implementation does not attempt to create it, and if it does not exist, an error occurs. name : The name of the secret object in Docker. This field can be used to reference secrets that contain special characters. The name is used as is and will not be scoped with the project name. In this example, server-certificate is created as <project_name>_server-certificate when the application is deployed, by registering content of the server.cert as a platform secret. 1 2 3 secrets: server-certificate: file: ./server.cert Alternatively, server-certificate can be declared as external, doing so Compose implementation will lookup server-certificate to expose secret to relevant services. 1 2 3 secrets: server-certificate: external: true External secrets lookup can also use a distinct key by specifying a name . The following example modifies the previous one to look up for secret using a parameter CERTIFICATE_KEY . Doing so the actual lookup key will be set at deployment time by interpolation of variables, but exposed to containers as hard-coded ID server-certificate . 1 2 3 4 secrets: server-certificate: external: true name: \"${CERTIFICATE_KEY}\" Compose file need to explicitly grant access to the secrets to relevant services in the application.","title":"Secrets top-level element"},{"location":"dev/docker/compose/spec/#fragments","text":"It is possible to re-use configuration fragments using YAML anchors . 1 2 3 4 volumes: db-data: &default-volume driver: default metrics: *default-volume In previous sample, an anchor is created as default-volume based on db-data volume specification. It is later reused by alias *default-volume to define metrics volume. Same logic can apply to any element in a Compose file. Anchor resolution MUST take place before variables interpolation , so variables can't be used to set anchors or aliases. It is also possible to partially override values set by anchor reference using the YAML merge type . In following example, metrics volume specification uses alias to avoid repetition but override name attribute: 1 2 3 4 5 6 7 8 9 10 11 12 13 services: backend: image: awesome/database volumes: - db-data - metrics volumes: db-data: &default-volume driver: default name: \"data\" metrics: <<: *default-volume name: \"metrics\"","title":"Fragments"},{"location":"dev/docker/compose/spec/#extension","text":"Special extension fields can be of any format as long as their name starts with the x- character sequence. They can be used within any structure in a Compose file. This is the sole exception for Compose implementations to silently ignore unrecognized field. 1 2 3 4 5 6 7 8 9 x-custom: foo: - bar - zot services: webapp: image: awesome/webapp x-foo: bar The contents of such fields are unspecified by Compose specification, and can be used to enable custom features. Compose implementation to encounter an unknown extension field MUST NOT fail, but COULD warn about unknown field. For platform extensions, it is highly recommended to prefix extension by platform/vendor name, the same way browsers add support for custom CSS features 1 2 3 4 5 6 7 service: backend: deploy: placement: x-aws-role: \"arn:aws:iam::XXXXXXXXXXXX:role/foo\" x-aws-region: \"eu-west-3\" x-azure-region: \"france-central\"","title":"Extension"},{"location":"dev/docker/compose/spec/#informative-historical-notes","text":"This section is informative. At the time of writing, the following prefixes are known to exist: prefix vendor/organization docker Docker kubernetes Kubernetes","title":"Informative Historical Notes"},{"location":"dev/docker/compose/spec/#using-extensions-as-fragments","text":"With the support for extension fields, Compose file can be written as follows to improve readability of reused fragments: 1 2 3 4 5 6 7 8 9 10 11 12 13 x-logging: &default-logging options: max-size: \"12m\" max-file: \"5\" driver: json-file services: frontend: image: awesome/webapp logging: *default-logging backend: image: awesome/database logging: *default-logging","title":"Using extensions as fragments"},{"location":"dev/docker/compose/spec/#specifying-byte-values","text":"Value express a byte value as a string in {amount}{byte unit} format: The supported units are b (bytes), k or kb (kilo bytes), m or mb (mega bytes) and g or gb (giga bytes). 1 2 3 4 5 2b 1024kb 2048k 300m 1gb","title":"specifying- byte values"},{"location":"dev/docker/compose/spec/#specifying-durations","text":"Value express a duration as a string in thte in the form of {value}{unit} . The supported units are us (microseconds), ms (milliseconds), s (seconds), m (minutes) and h (hours). Value can can combine mutiple values and using without separator. 1 2 3 4 10ms 40s 1m30s 1h5m30s20ms","title":"specifying durations"},{"location":"dev/docker/compose/spec/#interpolation","text":"Values in a Compose file can be set by variables, and interpolated at runtime. Compose files use a Bash-like syntax ${VARIABLE} Both $VARIABLE and ${VARIABLE} syntax are supported. Default values can be defined inline using typical shell syntax: latest ${VARIABLE:-default} evaluates to default if VARIABLE is unset or empty in the environment. ${VARIABLE-default} evaluates to default only if VARIABLE is unset in the environment. Similarly, the following syntax allows you to specify mandatory variables: ${VARIABLE:?err} exits with an error message containing err if VARIABLE is unset or empty in the environment. ${VARIABLE?err} exits with an error message containing err if VARIABLE is unset in the environment. Other extended shell-style features, such as ${VARIABLE/foo/bar} , are not supported by the Compose specification. You can use a $$ (double-dollar sign) when your configuration needs a literal dollar sign. This also prevents Compose from interpolating a value, so a $$ allows you to refer to environment variables that you don't want processed by Compose. 1 2 3 web: build: . command: \"$$VAR_NOT_INTERPOLATED_BY_COMPOSE\" If the Compose implementation can't resolve a substituted variable and no default value is defined, it MUST warn the user and substitute the variable with an empty string. As any values in a Compose file can be interpolated with variable substitution, including compact string notation for complex elements, interpolation MUST be applied before merge on a per-file-basis.","title":"Interpolation"},{"location":"dev/git/cheatsheet/","text":"git Cheatsheet \u2693\ufe0e Remotes \u2693\ufe0e Task Command Set default upstream branch 1 git config push.default {remote-name} Local Filesystem \u2693\ufe0e Task Command Delete a file from repo without deleting local file git rm --cached {file-name} Delete a directory from repo without deleting local directory git rm --cached -r {directory-name} table code { white-space:nowrap; -moz-user-select: all; -webkit-user-select: all; -ms-user-select: all; } Git push: set target for branch \u21a9","title":"Git"},{"location":"dev/git/cheatsheet/#git-cheatsheet","text":"","title":"git Cheatsheet"},{"location":"dev/git/cheatsheet/#remotes","text":"Task Command Set default upstream branch 1 git config push.default {remote-name}","title":"Remotes"},{"location":"dev/git/cheatsheet/#local-filesystem","text":"Task Command Delete a file from repo without deleting local file git rm --cached {file-name} Delete a directory from repo without deleting local directory git rm --cached -r {directory-name} table code { white-space:nowrap; -moz-user-select: all; -webkit-user-select: all; -ms-user-select: all; } Git push: set target for branch \u21a9","title":"Local Filesystem"},{"location":"dev/linux/bash/refs/","text":"Bash References \u2693\ufe0e Flags \u2693\ufe0e","title":"Bash References"},{"location":"dev/linux/bash/refs/#bash-references","text":"","title":"Bash References"},{"location":"dev/linux/bash/refs/#flags","text":"","title":"Flags"},{"location":"dev/linux/ubuntu/versions/","text":"Ubuntu / Debian Version Names \u2693\ufe0e Ubuntu , the popular Linux distribution, is based on the Debian Linux distribution. Sometimes you will see Ubuntu and Debian versions referred to by their version number or code name alternatively. There isn't a great reference out there on which how those the map together. Below is a port of a very helpful StackOverflow answer that has this info. 1 Ubuntu Debian Version Name Name Version 20.04 focal bullseye 11 19.10 eoan buster 10 19.04 disco buster 10 18.10 cosmic buster 10 18.04 bionic buster 10 17.10 artful stretch 9 17.04 zesty stretch 9 16.10 yakkety stretch 9 16.04 xenial stretch 9 15.10 wily jessie 8 15.04 vivid jessie 8 14.10 utopic jessie 8 14.04 trusty jessie 8 13.10 saucy wheezy 7 13.04 raring wheezy 7 12.10 quantal wheezy 7 12.04 precise wheezy 7 11.10 oneiric wheezy 7 11.04 natty squeeze 6 10.10 maverick squeeze 6 10.04 lucid squeeze 6 table tbody tr td:nth-child(2), table thead tr.sub th:nth-child(2){border-right:1px solid #Efefef !important} What Debian version are the different Ubuntu versions based on? \u21a9","title":"Ubuntu"},{"location":"dev/linux/ubuntu/versions/#ubuntu-debian-version-names","text":"Ubuntu , the popular Linux distribution, is based on the Debian Linux distribution. Sometimes you will see Ubuntu and Debian versions referred to by their version number or code name alternatively. There isn't a great reference out there on which how those the map together. Below is a port of a very helpful StackOverflow answer that has this info. 1 Ubuntu Debian Version Name Name Version 20.04 focal bullseye 11 19.10 eoan buster 10 19.04 disco buster 10 18.10 cosmic buster 10 18.04 bionic buster 10 17.10 artful stretch 9 17.04 zesty stretch 9 16.10 yakkety stretch 9 16.04 xenial stretch 9 15.10 wily jessie 8 15.04 vivid jessie 8 14.10 utopic jessie 8 14.04 trusty jessie 8 13.10 saucy wheezy 7 13.04 raring wheezy 7 12.10 quantal wheezy 7 12.04 precise wheezy 7 11.10 oneiric wheezy 7 11.04 natty squeeze 6 10.10 maverick squeeze 6 10.04 lucid squeeze 6 table tbody tr td:nth-child(2), table thead tr.sub th:nth-child(2){border-right:1px solid #Efefef !important} What Debian version are the different Ubuntu versions based on? \u21a9","title":"Ubuntu / Debian Version Names"},{"location":"dev/php/gearman/","text":"Gearman \u2693\ufe0e Gearman is (as far as I can tell) a now defunct message queue system that made it relatively easy to send messages from one script to another. I used Gearman extensively with PHP in days of yore. I would not recommend you do this today. 1 2 3 4 5 6 7 RUN apt-get install -y libboost-all-dev gperf libevent-dev uuid-dev RUN wget https://github.com/gearman/gearmand/releases/download/ ${ GEARMAND_VERSION } /gearmand- ${ GEARMAND_VERSION } .tar.gz && \\ tar -xzf gearmand- ${ GEARMAND_VERSION } .tar.gz && \\ cd gearmand- ${ GEARMAND_VERSION } && \\ ./configure && \\ make && \\ make install","title":"Gearman"},{"location":"dev/php/gearman/#gearman","text":"Gearman is (as far as I can tell) a now defunct message queue system that made it relatively easy to send messages from one script to another. I used Gearman extensively with PHP in days of yore. I would not recommend you do this today. 1 2 3 4 5 6 7 RUN apt-get install -y libboost-all-dev gperf libevent-dev uuid-dev RUN wget https://github.com/gearman/gearmand/releases/download/ ${ GEARMAND_VERSION } /gearmand- ${ GEARMAND_VERSION } .tar.gz && \\ tar -xzf gearmand- ${ GEARMAND_VERSION } .tar.gz && \\ cd gearmand- ${ GEARMAND_VERSION } && \\ ./configure && \\ make && \\ make install","title":"Gearman"},{"location":"dev/php/official-docker/","text":"The Official PHP Docker Image \u2693\ufe0e The official PHP Docker image is a good starting place for many PHP projects. It's a rock-solid implementation of PHP with close attention paid to best practices for PHP. The downside of this image is that it is not covered in the main different articles and blog posts on the Internet that cover how to configure PHP. This page is where I try to fill in some of the gaps. Location of Installed Resources \u2693\ufe0e Configuration Files \u2693\ufe0e While configuring your application you may need to update the default configuration settings for the image. The table below lists the locations of some of these files. Configuration Location Image Variant PEAR /usr/local/etc/pear.conf All PHP-FPM Enabled /usr/local/etc/php-fpm.conf FPM PHP-FPM Enabled Site /usr/local/etc/php-fpm.d/www.conf FPM Key Binaries \u2693\ufe0e Below are some of the key binary files that you may need to know about and whether or not they are on the PATH . Binaries Location Image Variant On PATH ? FPM Binary /usr/local/sbin/php-fpm FPM Yes PHPize /usr/local/bin/phpize All Yes","title":"Official Docker"},{"location":"dev/php/official-docker/#the-official-php-docker-image","text":"The official PHP Docker image is a good starting place for many PHP projects. It's a rock-solid implementation of PHP with close attention paid to best practices for PHP. The downside of this image is that it is not covered in the main different articles and blog posts on the Internet that cover how to configure PHP. This page is where I try to fill in some of the gaps.","title":"The Official PHP Docker Image"},{"location":"dev/php/official-docker/#location-of-installed-resources","text":"","title":"Location of Installed Resources"},{"location":"dev/php/official-docker/#configuration-files","text":"While configuring your application you may need to update the default configuration settings for the image. The table below lists the locations of some of these files. Configuration Location Image Variant PEAR /usr/local/etc/pear.conf All PHP-FPM Enabled /usr/local/etc/php-fpm.conf FPM PHP-FPM Enabled Site /usr/local/etc/php-fpm.d/www.conf FPM","title":"Configuration Files"},{"location":"dev/php/official-docker/#key-binaries","text":"Below are some of the key binary files that you may need to know about and whether or not they are on the PATH . Binaries Location Image Variant On PATH ? FPM Binary /usr/local/sbin/php-fpm FPM Yes PHPize /usr/local/bin/phpize All Yes","title":"Key Binaries"},{"location":"dev/py/pip/","text":"Working with pip \u2693\ufe0e Serializing Project Package Dependencies \u2693\ufe0e pip doesn't have an automatic mechanism for serializing the different project dependencies you have. Typically with a Python project, you would document your project's dependencies in a requirements.txt file. This would allow you to quickly re-install all your dependencies when the project is moved to a new machine or re-build for a deployment. Default Option: pip freeze \u2693\ufe0e You can use the freeze command, however, to output all of the dependencies you have installed and that output can then be sent to a requirements.txt file using the command below: 1 pip freeze > requirements.txt Serialize all pip modules. Better Option: pipreqs \u2693\ufe0e The pipreqs package can be used to create requirements.txt files with just the packages used in your local project. Since pip freeze saves all of the packages in your environment\u2014including the ones you don't actually use in your project, pipreqs is a cleaner solution. To install pipreqs : 1 pip install pipreqs You can then generate your project's requirements using the global pipreqs command: 1 2 $ pipreqs /project/location Successfully saved requirements file in /project/location/requirements.txt","title":"pip"},{"location":"dev/py/pip/#working-with-pip","text":"","title":"Working with pip"},{"location":"dev/py/pip/#serializing-project-package-dependencies","text":"pip doesn't have an automatic mechanism for serializing the different project dependencies you have. Typically with a Python project, you would document your project's dependencies in a requirements.txt file. This would allow you to quickly re-install all your dependencies when the project is moved to a new machine or re-build for a deployment.","title":"Serializing Project Package Dependencies"},{"location":"dev/py/pip/#default-option-pip-freeze","text":"You can use the freeze command, however, to output all of the dependencies you have installed and that output can then be sent to a requirements.txt file using the command below: 1 pip freeze > requirements.txt Serialize all pip modules.","title":"Default Option: pip freeze"},{"location":"dev/py/pip/#better-option-pipreqs","text":"The pipreqs package can be used to create requirements.txt files with just the packages used in your local project. Since pip freeze saves all of the packages in your environment\u2014including the ones you don't actually use in your project, pipreqs is a cleaner solution. To install pipreqs : 1 pip install pipreqs You can then generate your project's requirements using the global pipreqs command: 1 2 $ pipreqs /project/location Successfully saved requirements file in /project/location/requirements.txt","title":"Better Option: pipreqs"},{"location":"dev/sql/sql-server/","text":"SQL Server \u2693\ufe0e Find any Procedures Containing <text> \u2693\ufe0e You can use these queries 1 to search for stored procedures that contain the value Foo . 1 2 3 4 5 SELECT OBJECT_NAME ( id ) FROM SYSCOMMENTS WHERE [ text ] LIKE '%Foo%' AND OBJECTPROPERTY ( id , 'IsProcedure' ) = 1 GROUP BY OBJECT_NAME ( id ) 1 2 3 4 SELECT OBJECT_NAME ( object_id ) FROM sys . sql_modules WHERE OBJECTPROPERTY ( object_id , 'IsProcedure' ) = 1 AND definition LIKE '%Foo%' Warn Note that ROUTINE_DEFINITION is cropped at 4,000 characters. It's recommended to use one of the methods above using OBJECTPROPERTY instead. 1 2 3 4 SELECT ROUTINE_NAME , ROUTINE_DEFINITION FROM INFORMATION_SCHEMA . ROUTINES WHERE ROUTINE_DEFINITION LIKE '%Foo%' AND ROUTINE_TYPE = 'PROCEDURE' See: https://stackoverflow.com/q/5079457/1356593 \u21a9","title":"SQL Server"},{"location":"dev/sql/sql-server/#sql-server","text":"","title":"SQL Server"},{"location":"dev/sql/sql-server/#find-any-procedures-containing-text","text":"You can use these queries 1 to search for stored procedures that contain the value Foo . 1 2 3 4 5 SELECT OBJECT_NAME ( id ) FROM SYSCOMMENTS WHERE [ text ] LIKE '%Foo%' AND OBJECTPROPERTY ( id , 'IsProcedure' ) = 1 GROUP BY OBJECT_NAME ( id ) 1 2 3 4 SELECT OBJECT_NAME ( object_id ) FROM sys . sql_modules WHERE OBJECTPROPERTY ( object_id , 'IsProcedure' ) = 1 AND definition LIKE '%Foo%' Warn Note that ROUTINE_DEFINITION is cropped at 4,000 characters. It's recommended to use one of the methods above using OBJECTPROPERTY instead. 1 2 3 4 SELECT ROUTINE_NAME , ROUTINE_DEFINITION FROM INFORMATION_SCHEMA . ROUTINES WHERE ROUTINE_DEFINITION LIKE '%Foo%' AND ROUTINE_TYPE = 'PROCEDURE' See: https://stackoverflow.com/q/5079457/1356593 \u21a9","title":"Find any Procedures Containing &lt;text&gt;"},{"location":"tech/my-stack/","text":"My Stack \u2693\ufe0e I recently had the pleasure of installing the Big Sur beta, having it totally corrupt my system, and having to re-install the OS from scratch. Through that process I boiled down the the base-level app ecosystem I use day to day and wanted to share it with you. Utilities \u2693\ufe0e Paste \u2693\ufe0e Paste is a fantastic clipboard manager application that saves items you copy to your clipboard into a tray at the bottom of your screen. It also provides a satisfying \"click\" sound when an item is copied to the clipboard\u2014a feature that is extremely helpful when copying MFA codes from your iPhone. 1Password \u2693\ufe0e Arguably the most important application you could have is some sort of password manager. There are many different options out there. I tried LastPass in the past but ultimately selected 1Password. It has a deep integration with MacOS and iOS which helps keep things simple. Bartender \u2693\ufe0e The number of apps providing compact menu bar apps for MacOS greatly outpaces the amount of space that exists in the menu bar itself. Bartender helps clear up space by allowing you to hide your less-used menu bar application. Pro Tip You can rearrange your menubar applications natively (with no app needed) by holding down ^ Ctrl and then clicking and dragging the menubar app.","title":"My Stack"},{"location":"tech/my-stack/#my-stack","text":"I recently had the pleasure of installing the Big Sur beta, having it totally corrupt my system, and having to re-install the OS from scratch. Through that process I boiled down the the base-level app ecosystem I use day to day and wanted to share it with you.","title":"My Stack"},{"location":"tech/my-stack/#utilities","text":"","title":"Utilities"},{"location":"tech/my-stack/#paste","text":"Paste is a fantastic clipboard manager application that saves items you copy to your clipboard into a tray at the bottom of your screen. It also provides a satisfying \"click\" sound when an item is copied to the clipboard\u2014a feature that is extremely helpful when copying MFA codes from your iPhone.","title":"Paste"},{"location":"tech/my-stack/#1password","text":"Arguably the most important application you could have is some sort of password manager. There are many different options out there. I tried LastPass in the past but ultimately selected 1Password. It has a deep integration with MacOS and iOS which helps keep things simple.","title":"1Password"},{"location":"tech/my-stack/#bartender","text":"The number of apps providing compact menu bar apps for MacOS greatly outpaces the amount of space that exists in the menu bar itself. Bartender helps clear up space by allowing you to hide your less-used menu bar application. Pro Tip You can rearrange your menubar applications natively (with no app needed) by holding down ^ Ctrl and then clicking and dragging the menubar app.","title":"Bartender"}]}